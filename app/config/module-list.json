[
  {
    "module": "VUE",
    "title": "vue知识总结",
    "views": [
      {
        "module": "VUE",
        "title": "vue使用技巧",
        "introduction": "父组件捕获子组件提交的refresh事件,这个事件也一并传递两个参数,此时父组件是个for循环组件,需要拿到当前index子组件父组件父组件捕获事件自定义一个事件，然后调用父组件内部的方法子组件会因为父组件传递过来的值，初始化显示，然后子组件又存在操作行为，又要把这个值提交给父组件默认情况下，我们会在子组件重新定义一个变量，子组件创建的时候，把传递进来的值，赋值给这个变量，然后监听这个变量的变化，分发事件把值再传递给父组件这样就会有很多问题：比如子组件的显示与隐藏并不是通过v-if来控制，而是通过v-show来控制的，当父组件改变了name的值，再次显示子组件的时候初始值就有可能不对最简单有效的方式：computed通过计算属性的get以及set方法，无论在什么情况都能初始化值以及提交子组件的值默认自定义插件里面的函数是读取不到this的，this是undefined，但是可以通过虚拟DOM获取",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/skill"
      },
      {
        "module": "VUE",
        "title": "注册Vue插件",
        "introduction": "Vue.use接收两种类型的参数，可以是Object，也可以是Function，当接收的参数是个对象的时候，Vue会调用install方法，当接收的参数是个方法的时候，就会直接调用该方法",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/plugin"
      },
      {
        "module": "VUE",
        "title": "深入render函数",
        "introduction": "通过render函数创建组件可以不设置根节点返回值必须是个VNode虚拟DOM虚拟节点VNode的data对象有下面这些高级属性可以通过jsx来创建组件",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/render"
      },
      {
        "module": "VUE",
        "title": "抽象组件",
        "introduction": "我们常用的transition和keep-alive就是一个抽象组件。抽象组件是无状态的，同样也是“不存在的”，它自己并不会被渲染为实际的DOM，而是直接返回以及操作它的子元素。把函数防抖/函数节流包装成通用组件在render函数中，组件修改子VNode的事件，再将其返回回去。使用：使用自定义指令也是一种思路，不过指令的bind发生在created的回调中，也就是晚于事件的初始化的，这样的话就不能通过修改vnode.data.on来改变绑定的事件回调，只能自己来绑定事件了：",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/abstract"
      },
      {
        "module": "VUE",
        "title": "收集Vue性能",
        "introduction": "打开performance开关这将激活Vue在内部用于标记组件性能的User Timing API。打开它并点击Chrome DevTools上的性能标签中的重新加载按钮：利用Chrome DevTools查看performance栏下的User Timing利用js",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/measureVuePerformance"
      },
      {
        "module": "VUE",
        "title": "扩展Vue组件",
        "introduction": "",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/expand"
      },
      {
        "module": "VUE",
        "title": "$listeners的使用技巧",
        "introduction": "比如说包装了一个input组件，但是这个组件可能分发各种类型的事件：为了减少代码量，我们可以通过$listeners直接绑定事件：原理就是：v-on可以绑定一个监听器键值对的对象，这样绑定相当于发生了绑定的事件后，会直接调用监听器值的方法，而不是通过提交($emit)的方式通过$emit的方式是不能拿到返回值的，因为$emit相当于是分发一个事件，父组件有一个监听事件，是个异步操作，是不能返回值但是通过$listeners对象拿到绑定的事件的方法，直接调用，就可能拿到返回值了",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/listeners"
      },
      {
        "module": "VUE",
        "title": "更新title的另一种思路",
        "introduction": "路由组件内部使用：组件内部使用：",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/setTitle"
      },
      {
        "module": "VUE",
        "title": "捕获子组件生命周期",
        "introduction": "有时候，需要知道子组件的生命周期，然后做一些事情通过@hooks:生命周期来实现监听在 _init方法中执行的，它的定义在src/core/instance/init.js中：源码中最终执行生命周期的函数都是调用callHook方法，它的定义在src/core/instance/lifecycle中：可以看到在调用生命周期的时候，除了调用以外，还会$emit一个hooks:生命周期事件可以看到beforeCreate和created的钩子调用是在 initState的前后，initState的作用是初始化props、data、methods、watch、computed等属性，之后我们会详细分析。那么显然beforeCreate的钩子函数中就不能获取到props、data中定义的值，也不能调用methods中定义的函数。在这俩个钩子函数执行的时候，并没有渲染DOM，所以我们也不能够访问DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问props、data等数据的话，就需要使用created钩子函数。",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/componentHooks"
      },
      {
        "module": "VUE",
        "title": "函数式组件",
        "introduction": ":::tip\n组件需要的一切都是通过上下文传递，包括：\n::::::tip\n在添加 functional: true 之后，锚点标题组件的 render 函数之间简单更新增加 context 参数，this.$slots.default 更新为 context.children，之后this.level 更新为 context.props.level。\n:::比如使用模板的形式:比如使用渲染函数的形式:",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/functionalComponent"
      },
      {
        "module": "VUE",
        "title": "vue性能优化",
        "introduction": ":::tip\n因为所有绑定在this上面的属性，都会增加get,set方法，也就是说你读取this.base的时候，实际会走一遍get方法，由于堆栈的原由，就会耗费时间\n:::Defer Mixin:::tip\n这样可以定制局部属性，不用Vue添加get,set方法\n:::vue-virtual-scroller",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/performance"
      },
      {
        "module": "VUE",
        "title": "调试Vue模板",
        "introduction": "说明::::warning\n在Vue模板中使用的属性和方法，都会从Vue的原型上面寻找，而不是window或者是别的，所以这段代码会报错。\n::::::tip\n为了不影响正常的渲染，可以使用或运算符\n:::说明::::warning\n这样调试器会进到这个断点这里，根本无法调试当前上下文\n:::那么我们应该怎么做呢::::tip\n我们可以使用一个小技巧，将调试器放在一个立即调用的函数表达式(IIFE)里面\n::::::warning\n但是这也有个问题，断点进入之后，由于是个闭包，所以并不能调试当前组件的实例(_vm)\n:::所以我们可以这样:这样就可以调试message以及当前vue实例",
        "moduleIntro": "vue知识总结",
        "path": "/VUE/debuggerTemplate"
      }
    ]
  },
  {
    "module": "CSS",
    "title": "css总结",
    "views": [
      {
        "module": "CSS",
        "title": "box-shadow",
        "introduction": "也就是说如果有多个Number类型的配置，\b肯定有offset-x,offset-y常见语法inset: 默认阴影在边框外。使用 inset 后，阴影在边框内（即使是透明边框），背景之上内容之下。也有些人喜欢把这个值放在最后，浏览器也支持。offset-x offset-y: 这是头两个 length值，用来设置阴影偏移量。offset-x 设置水平偏移量，如果是负值则阴影位于元素左边。 offset-y 设置垂直偏移量，如果是负值则阴影位于元素上面。可用单位请查看 length。如果两者都是0，那么阴影位于元素后面。这时如果设置了 blur-radius 或 spread-radius 则有模糊效果。blur-radius: 这是第三个 length 值。值越大，模糊面积越大，阴影就越大越淡。 不能为负值。默认为0，此时阴影边缘锐利。spread-radius : 这是第四个 length 值。取正值时，阴影扩大；取负值时，阴影收缩。默认为0，此时阴影与元素同样大。color : 相关事项查看 color 。如果没有指定，则由浏览器决定——通常是color的值，不过目前Safari取透明。",
        "moduleIntro": "css总结",
        "path": "/CSS/boxShadow"
      },
      {
        "module": "CSS",
        "title": "重新学习css选择器",
        "introduction": "基础选择器包括：通用选择器、标签选择器、类选择器、 id选择器组合选择器包括：多元素选择器、后代元素选择器、子元素选择器、毗邻选择器、相邻选择器毗(pi)邻：相互接触连接相邻：靠近，离得近的都叫相邻CSS1-2伪类选择器CSS3伪类选择器CSS3对伪类的定义：伪类存在的意义是为了通过选择器找到那些不存在与DOM树中的信息以及不能被常规CSS选择器获取到的信息。伪类由一个冒号:开头，冒号后面是伪类的名称和包含在圆括号中的可选参数。任何常规选择器可以再任何位置使用伪类。伪类语法不区别大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作DOM时产生的DOM结构改变，伪类也可以是动态的。其实第一段话就囊括CSS3伪类的全部定义了，这段话中指出CSS3伪类的功能有两种：获取不存在与DOM树中的信息。比如a链接的:link、:actived等，这些信息不存在DOM树结构中，只能通过css选择器来获取。获取不能被常规CSS选择器获取的信息。",
        "moduleIntro": "css总结",
        "path": "/CSS/selector"
      },
      {
        "module": "CSS",
        "title": "常用css片段",
        "introduction": "用法：",
        "moduleIntro": "css总结",
        "path": "/CSS/oftenCss"
      },
      {
        "module": "CSS",
        "title": "通过伪类获取列表总数",
        "introduction": "我们可以借助伪类判断当前列表个数，示意如下：:::tip\n然后借助兄弟元素选择符~，以及相邻元素选择符+就可以设置兄弟元素样式，达到不同列表数目，不一样布局的目的\n:::",
        "moduleIntro": "css总结",
        "path": "/CSS/cssGetListCount"
      },
      {
        "module": "CSS",
        "title": "切换皮肤方案",
        "introduction": "都不完美。全局class控制样式提高了样式优先级，如果换肤样式很多，代码会非常啰嗦，不利于维护；使用JS改变href属性会带来加载延迟，样式切换不流畅，体验不佳。:::tip\n有个非常有趣的特性，那就是rel=\"stylesheet\"的<link>如果有title属性并有值，性质上就变成了一个可以控制其渲染或者不渲染的特殊元素了。\n:::此方法借助HTML rel属性的alternate属性值实现。示意HTML如下：:::tip\n使用JS进行控制了，使用JavaScript代码修改<link>元素DOM对象的disabled值为false，可以让默认不渲染的CSS开始渲染。注意，必须是DOM元素对象的disabled属性，而不是HTML元素的disabled属性，<link>元素是没有disabled属性的\n:::",
        "moduleIntro": "css总结",
        "path": "/CSS/changeSkin"
      },
      {
        "module": "CSS",
        "title": "理解背景定位",
        "introduction": "产生的效果如下：重点来了，right bottom 这个值是什么意思呢？:::tip\n正确的理解：图片的右下角与div的右下角对齐\n:::那么就可以很容易的理解百分比了:::warning\nright bottom 就是 100% 100%\n::::::tip\n所以百分比：50% 50%就是图片的50%与div的50%对齐\n:::",
        "moduleIntro": "css总结",
        "path": "/CSS/backgroundPosition"
      },
      {
        "module": "CSS",
        "title": "理解ObjectFit",
        "introduction": "这两个奇葩的属性是搞毛的呢？其实它们是为了处理替换元素（replaced elements）的自适应问题，简单的说，就是处理替换元素的变形（这里指长宽比例变形）问题。等等，好像多了一个名词，啥叫替换元素？替换元素其实是：这个当然不是我头脑风暴来的，而是引用别人的解释：引用常见的替换元素有要是看的稀里糊涂的也没关系，接着往下看，我相信你会懂得！1、object-fit语法：object-fit: fill | contian | cover | none | scale-down;不好意思，我又要摆妹子来诱惑你们了，看效果图：上面的五个例子的代码：看到这些效果，我想同志们最关心的的应该是兼容性，点这里点这里2、object-positionobject-position 属性决定了它的盒子里面替换元素的对齐方式。语法：object-position:默认值是50% 50%，也就是居中效果，其取值和CSS中background-position属性取值一样。（如果不熟悉background-position，可以瞄瞄这里《CSS3 Background 》）例如：替换元素位于内容区域的左上角img{object-fit: contain;object-position: 0 0;效果图：例如：替换元素相对于左下角10px 10px地方定位img{object-fit: contain;object-position: bottom 10px left 10px;效果图：当然，你也可以使用calc()来定位：img{object-fit: contain;object-position: calc(100% - 10px) calc(100% - 10px);效果图：它还支持负数：img{object-fit: contain;object-position: -10px calc(100% - 10px);效果图：总之，object-position的特性表现与backgound-position一样一样的。到这里，这两个属性算是讲完了，就是这么简单。",
        "moduleIntro": "css总结",
        "path": "/CSS/objectFit"
      },
      {
        "module": "CSS",
        "title": "flex中神奇的margin",
        "introduction": ":::tip\n上面的 display: flex 替换成 display: inline-flex | grid | inline-grid 也是可以的。\n:::disaply:blockBFC(块格式化上下文也就是block formatting context),margin: auto只能使水平居中而不能使垂直居中。查看CSS 文档，发现原因如下：If both margin-left and margin-right are auto, their used values are equal, causing horizontal centring.\n—CSS2 Visual formatting model details: 10.3.3:::tip\n简单翻译下，在块格式化上下文中，如果margin-left和margin-right都是auto，则它们的表达值相等，则margin的计算值就是平均分配剩余空间，所以造成水平居中\n:::If margin-top, or margin-bottom are auto, their used value is 0.\nCSS2 Visual formatting model details: 10.6.3:::tip\n简单翻译下，在块格式化上下文中，而如果margin-top和margin-bottom都是auto则margin的计算值就是0，当然也就无法造成垂直居中。\n:::disaply:flexFFC(块格式化上下文也就是block formatting context)、display: gridGFC(grid formatting context)中,margin: auto可以水平垂直居中。查看CSS 文档，发现原因如下：Prior to alignment via justify-content and align-self, any positive free space is distributed to auto margins in that dimension.\nCSS Flexible Box Layout Module Level 1 -- 8.1. Aligning with auto margins:::tip\n简单翻译一下，大意是在FFC中，设置了 margin: auto 的元素，任何正处于空闲的空间都会分配到该方向的自动margin中去\n而且是在通过justify-content和align-items进行对齐之前\njustify-content和align-items的对齐方式，也是基础剩余空间的，比如justify-content: center，就是水平方向的两侧main-start和main-end平分剩余空间。w3c文档\n::::::warning\nFFC中设置了margin，那么就会先把剩余空间分配给margin使用，然后再有的剩余空间才会分配给justify-content和align-items使用。\n:::例如：在flex布局中实现一个右对齐:::tip\n理解了原理之后，可以处理更多布局。\n:::",
        "moduleIntro": "css总结",
        "path": "/CSS/flexAuto"
      },
      {
        "module": "CSS",
        "title": "css技巧",
        "introduction": "text-transform可以改变英文的大小写text-align-last:focus-within冒泡规则(兼容性不是很好)",
        "moduleIntro": "css总结",
        "path": "/CSS/skill"
      }
    ]
  },
  {
    "module": "ES6",
    "title": "常用ES6总结",
    "views": [
      {
        "module": "ES6",
        "title": "async/await使用",
        "introduction": "async方法的promise只要出现不是resolved的状态，async方法将直接返回，不再继续往下执行async方法返回的永远是个promise对象，如果方法内部出现错误，或者不是resolve状态,返回的就是个reject，如果没有发生错误，方法最终返回的是，await等待的promise以及后续所有的代码执行完毕的返回值，如果没有明确指定返回值，将返回一个resolve状态包含undefined的promise初级版： 每个 await 都写这么长，写着也不方便也不优雅最终版",
        "moduleIntro": "常用ES6总结",
        "path": "/ES6/async"
      },
      {
        "module": "ES6",
        "title": "class用法总结",
        "introduction": "在constructor里面定义的属性和方法都是实例属性和方法，什么事实例属性和方法呢，就是说在new的时候都会重新执行和创建这些实例和方法实例化之后：直接prototype上面定义通过get方式定义实例化之后：什么是静态属性静态方法：只能通过类本身来调用，不能通过类的实例来调用这就说明几个问题：静态方法之间可以相互调用，非静态方法就不能调用静态方法非静态方法可以通过类名来调用静态方法我们知道申明原型属性才用偏门的方法get的方式，那么通过static结合get的方式就可以申明一个静态属性为什么要把super调用放在第一行，或者说为什么要在使用this之前，调用super方法super相当于调用父类的构造函数constructor，如果不先调用super方法那么父类就没有执行构造函数，也就是不能访问父类的实例方法和属性子类没有定义constructor方法子类没有定义constructor方法，相当于自动调用了super方法，必须会把实例化子类时候传递的参数，一样的传递给父类的构造函数constructor；定义了constructor方法，那么就必须调用super方法直接通过父类变量访问通过super访问super对象(不是super方法)只能在静态方法里面访问，所以通过super访问父类的静态数据也只能在子类的静态方法里面使用",
        "moduleIntro": "常用ES6总结",
        "path": "/ES6/class"
      },
      {
        "module": "ES6",
        "title": "Promise题目解析",
        "introduction": "实现原理：可以看到执行then方法，无论什么状态都返回一个Promise对象实现原理：也就是.then会创建一个Promise，这个Promise里面会判断then传入的回调函数是否是个Promise，如果是个Promise，那么就会等回调函数的里面的Promise执行完毕，才调用then创建的Promise的onResolved或者onRejected实现原理：可以看到是直接返回一个Promise，内部调用resolve，将状态改变成resolved状态实现原理：可以看到是直接返回一个Promise，内部调用reject，将状态改变成rejected状态接收一个promise数组返回一个新的Promise，将所有的resolve结果放进一个数组里面只要有一个 promise 变成rejected，这个新的 promise 将会被 rejected也会返回一个resolved状态的Promise，除非再手动抛出一个错误多个Promise嵌套，只需要一个catch方法就可以捕获只要前面的Promise发生错误，就会直接进入这个Promise后面的catch（不仅限于紧跟后面的）.catch和onRejected不能同时捕获到错误，而且是onRejected的优先级高于catch，可以理解为onRejected带代码逻辑在catch之前，只要是.catch能捕获到的错误，onRejected都能捕获到，无论是代码逻辑错误，还是通过reject抛出的错误内部Promise的错误，外部是无法捕获的因为try catch只能捕获同步错误，所有内部的Promise，外部是无法捕获的正确的理解内部Promise.then会立马执行传入的回调，如果回调的执行结果是Promise那么直接返回这个Promise，如果不是将创建一个Promise,返回出去,所以这里的Promise是属于外部的",
        "moduleIntro": "常用ES6总结",
        "path": "/ES6/promiseTopic"
      },
      {
        "module": "ES6",
        "title": "关于for..of的使用",
        "introduction": "ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内也就是说只要元素具有Symbol.iterator属性就可以使用for..of比如Array类型:比如Object类型不能使用又比如自定义了Symbol.iterator属性就可以使用了for..in循环读取键名，for..of循环读取键值。如果要通过for..of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法提取索引以及值要注意数组实例的entries(),keys(),values()和Object.entries(),Object.keys(),Object.values()的区分数组也可以调用Object的entries(),keys(),values()，只不过获取的下标都是字符串类型的",
        "moduleIntro": "常用ES6总结",
        "path": "/ES6/forOf"
      },
      {
        "module": "ES6",
        "title": "在循环中使用异步",
        "introduction": "异步函数在循环中执行，而且要以串行的方式，只能用for,for...in,for...of这几种方法才可以，因为别的遍历方式都是在for的基础上重构的，没有办法，让重构的方法变成async方法这几种原生遍历的方式是可以的实现串行的看下forEach的实现方式就知道这些重构过后的遍历，是不可以实现串行异步的可以看到，无论你传递给forEach的回调函数，是不是异步的函数，都将在内部遍历的时候，持续被调用，不存在等待的现象要实现并行执行，而且需要知道执行完毕的时机，基本上所有的遍历配合Promise.allo都可以实现",
        "moduleIntro": "常用ES6总结",
        "path": "/ES6/forAwait"
      },
      {
        "module": "ES6",
        "title": "新的ES6语法",
        "introduction": "目前 TC39 提案中有一个功能叫『可选链式调用』。这个新的运算符看起来像这样解决深层对象读取key的问题最新的babel已经支持，需要安装插件@babel/plugin-proposal-optional-chaining\n:::warning\n可惜不能在Vue模板引擎里面使用，因为模板引擎不支持，也没有打算支持\n:::当然也可以用lodash/get解决深层对象的问题",
        "moduleIntro": "常用ES6总结",
        "path": "/ES6/newEs6"
      }
    ]
  },
  {
    "module": "chrome",
    "title": "chrome使用总结",
    "views": [
      {
        "module": "chrome",
        "title": "Chrome使用的一些技巧",
        "introduction": "默认enter是执行输入的代码，可使用组合键enter+shift来实现在控制台换行输入Chrome等浏览器自带一个console.time()和console.timeEnd()方法，能够用更简单的代码实现上述功能。当需要统计一段代码的执行时间时，可以使用console.time方法与console.timeEnd方法，其中console.time方法用于标记开始时间，console.timeEnd方法用于标记结束时间，并且将结束时间与开始时间之间经过的毫秒数在控制台中输出。这两个方法的使用方法如下所示。这两个方法均使用一个参数，参数值可以为任何字符串，但是这两个方法所使用的参数字符串必须相同，才能正确地统计出开始时间与结束时间之间所经过的毫秒数。console.profile和console.profileEnd用来分析代码片段的使用cpu情况，使用方法和console.time一样，只是在查看搜集到的数据的时候要在Javascript Profiler面板查看，在控制台三个点菜单->更多工具->Javascript Profiler",
        "moduleIntro": "chrome使用总结",
        "path": "/chrome/skill"
      },
      {
        "module": "chrome",
        "title": "devTool里面performance",
        "introduction": "在performance面板，按Command+F(Mac) 或者Control+F(Windows, Linux)，可以打开面板底部的搜索框执行搜索单击捕获设置显示更多设置禁用Disable JavaScript Samples将只显示高级事件，隐藏调用堆栈启用，将显示所有的堆栈信息使用Interactions部分查看和分析录制期间发生的用户交互使用Frames部分确切的告诉你每帧花费的时间将鼠标悬停在上面，可以查看更多信息在分析像Network或者Main这样的部分时，有时需要更精确的估计某些事件花费的事件。按住Shift，鼠标点击并按住，然后向左或者向右移动，可以在DevTools显示该部分花了多长时间。先启用高级图层功能Enable advanced paint instrumentation(slow)然后在Frames部分选择一帧。然后在Layers选项卡中显示有关其图层信息先启用高级图层功能Enable advanced paint instrumentation(slow)然后在Main部分选择Paint事件在Paint Profiler选项卡查看打开Rendering选项卡这表明存在一个全局的mousewheel事件，可能损害滚动性能。",
        "moduleIntro": "chrome使用总结",
        "path": "/chrome/performance"
      },
      {
        "module": "chrome",
        "title": "原生懒加载",
        "introduction": "可以适用于图片(<img />)，以及iframe(<iframe>)",
        "moduleIntro": "chrome使用总结",
        "path": "/chrome/nativeLazy"
      }
    ]
  },
  {
    "module": "newAPI",
    "title": "新的API",
    "views": [
      {
        "module": "newAPI",
        "title": "Lifecycle监听网页冻结,激活,卸载",
        "introduction": "两周前，我介绍了 Page Visibility API。有了它，就可以监听各种情况的网页卸载。但是，它没有解决一个问题。Android、iOS 和最新的 Windows 系统可以随时自主地停止后台进程，及时释放系统资源。也就是说，网页可能随时被系统丢弃掉。Page Visibility API 只在网页对用户不可见时触发，至于网页会不会被系统丢弃掉，它就无能为力了。为了解决这个问题，W3C 新制定了一个 Page Lifecycle API，统一了网页从诞生到卸载的行为模式，并且定义了新的事件，允许开发者响应网页状态的各种转换。有了这个 API，开发者就可以预测网页下一步的状态，从而进行各种针对性的处理。Chrome 68 支持这个 API，对于老式浏览器可以使用谷歌开发的兼容库 PageLifecycle.js。网页的生命周期分成六个阶段，每个时刻只可能处于其中一个阶段。（1）Active 阶段在 Active 阶段，网页处于可见状态，且拥有输入焦点。（2）Passive 阶段在 Passive 阶段，网页可见，但没有输入焦点，无法接受输入。UI 更新（比如动画）仍然在执行。该阶段只可能发生在桌面同时有多个窗口的情况。（3）Hidden 阶段在 Hidden 阶段，用户的桌面被其他窗口占据，网页不可见，但尚未冻结。UI 更新不再执行。（4）Terminated 阶段在 Terminated 阶段，由于用户主动关闭窗口，或者在同一个窗口前往其他页面，导致当前页面开始被浏览器卸载并从内存中清除。注意，这个阶段总是在 Hidden 阶段之后发生，也就是说，用户主动离开当前页面，总是先进入 Hidden 阶段，再进入 Terminated 阶段。这个阶段会导致网页卸载，任何新任务都不会在这个阶段启动，并且如果运行时间太长，正在进行的任务可能会被终止。（5）Frozen 阶段如果网页处于 Hidden 阶段的时间过久，用户又不关闭网页，浏览器就有可能冻结网页，使其进入 Frozen 阶段。不过，也有可能，处于可见状态的页面长时间没有操作，也会进入 Frozen 阶段。这个阶段的特征是，网页不会再被分配 CPU 计算资源。定时器、回调函数、网络请求、DOM 操作都不会执行，不过正在运行的任务会执行完。浏览器可能会允许 Frozen 阶段的页面，周期性复苏一小段时间，短暂变回 Hidden 状态，允许一小部分任务执行。（6）Discarded 阶段如果网页长时间处于 Frozen 阶段，用户又不唤醒页面，那么就会进入 Discarded 阶段，即浏览器自动卸载网页，清除该网页的内存占用。不过，Passive 阶段的网页如果长时间没有互动，也可能直接进入 Discarded 阶段。这一般是在用户没有介入的情况下，由系统强制执行。任何类型的新任务或 JavaScript 代码，都不能在此阶段执行，因为这时通常处在资源限制的状况下。网页被浏览器自动 Discarded 以后，它的 Tab 窗口还是在的。如果用户重新访问这个 Tab 页，浏览器将会重新向服务器发出请求，再一次重新加载网页，回到 Active 阶段。以下是几个常见场景的网页生命周期变化。（1）用户打开网页后，又切换到其他 App，但只过了一会又回到网页。网页由 Active 变成 Hidden，又变回 Active。（2）用户打开网页后，又切换到其他 App，并且长时候使用后者，导致系统自动丢弃网页。网页由 Active 变成 Hidden，再变成 Frozen，最后 Discarded。（3）用户打开网页后，又切换到其他 App，然后从任务管理器里面将浏览器进程清除。网页由 Active 变成 Hidden，然后 Terminated。（4）系统丢弃了某个 Tab 里面的页面后，用户重新打开这个 Tab。网页由 Discarded 变成 Active。生命周期的各个阶段都有自己的事件，以供开发者指定监听函数。这些事件里面，只有两个是新定义的（ freeze事件和 resume事件），其它都是现有的。注意，网页的生命周期事件是在所有帧（frame）触发，不管是底层的帧，还是内嵌的帧。也就是说，内嵌的 <iframe></iframe>网页跟顶层网页一样，都会同时监听到下面的事件。focus事件在页面获得输入焦点时触发，比如网页从 Passive 阶段变为 Active 阶段。blur事件在页面失去输入焦点时触发，比如网页从 Active 阶段变为 Passive 阶段。visibilitychange事件在网页可见状态发生变化时触发，一般发生在以下几种场景。可以通过 document.onvisibilitychange属性指定这个事件的回调函数。freeze事件在网页进入 Frozen 阶段时触发。可以通过 document.onfreeze属性指定在进入 Frozen 阶段时调用的回调函数。这个事件的监听函数，最长只能运行500毫秒。并且只能复用已经打开的网络连接，不能发起新的网络请求。注意，从 Frozen 阶段进入 Discarded 阶段，不会触发任何事件，无法指定回调函数，只能在进入 Frozen 阶段时指定回调函数。resume事件在网页离开 Frozen 阶段，变为 Active / Passive / Hidden 阶段时触发。document.onresume属性指的是页面离开 Frozen 阶段、进入可用状态时调用的回调函数。pageshow事件在用户加载网页时触发。这时，有可能是全新的页面加载，也可能是从缓存中获取的页面。如果是从缓存中获取，则该事件对象的 event.persisted属性为 true，否则为 false。这个事件的名字有点误导，它跟页面的可见性其实毫无关系，只跟浏览器的 History 记录的变化有关。pagehide事件在用户离开当前网页、进入另一个网页时触发。它的前提是浏览器的 History 记录必须发生变化，跟网页是否可见无关。如果浏览器能够将当前页面添加到缓存以供稍后重用，则事件对象的 event.persisted属性为 true。 如果为 true。如果页面添加到了缓存，则页面进入 Frozen 状态，否则进入 Terminatied 状态。beforeunload事件在窗口或文档即将卸载时触发。该事件发生时，文档仍然可见，此时卸载仍可取消。经过这个事件，网页进入 Terminated 状态。unload事件在页面正在卸载时触发。经过这个事件，网页进入 Terminated 状态。如果网页处于 Active、Passive 或 Hidden 阶段，可以通过下面的代码，获得网页当前的状态。如果网页处于 Frozen 和 Terminated 状态，由于定时器代码不会执行，只能通过事件监听判断状态。进入 Frozen 阶段，可以监听 freeze事件；进入 Terminated 阶段，可以监听 pagehide事件。如果某个选项卡处于 Frozen 阶段，就随时有可能被系统丢弃，进入 Discarded 阶段。如果后来用户再次点击该选项卡，浏览器会重新加载该页面。这时，开发者可以通过判断 document.wasDiscarded属性，了解先前的网页是否被丢弃了。同时， window对象上会新增 window.clientId和 window.discardedClientId两个属性，用来恢复丢弃前的状态。（完）",
        "moduleIntro": "新的API",
        "path": "/newAPI/LifecycleAPI"
      }
    ]
  },
  {
    "module": "Tools",
    "title": "项目管理工具",
    "views": [
      {
        "module": "Tools",
        "title": "npm使用技巧",
        "introduction": "这个实在npmv5.2.0引入的一条命令。引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。举个例子，我们开发中要运行 parcel 命令来打包：parcel index.html，以前有这么几种方式：全局安装 parcel，但有时不同项目使用不同版本，不允许使用全局包，只能考虑下面一些方法使用 npm scripts，在 package.json 加一个 script将 node_modules 的可执行目录加到 PATH 中指定可执行命令路径现在我们有了npx命令，就不在需要考虑以上方法了（其实\n npx是对方法 3 的封装）。当我们执行npx parcel index.html时，会自动去./node_modules/.bin目录下搜索npx还允许我们单次执行命令而不需要安装，例如：这条命令会临时安装 create-react-app 包，命令完成后 create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。npm 允许在package.json文件里面，使用scripts字段定义脚本命令。上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。命令行下使用npm run命令，就可以执行这段脚本。这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。项目的相关脚本，可以集中在一个地方。不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。可以利用 npm 提供的很多辅助功能。查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。而不用写成下面这样。由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。上面代码中，*表示任意文件名，**表示任意一层子目录。如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。向 npm 脚本传入参数，要使用--标明。向上面的npm run lint命令传入参数，必须写成下面这样。也可以在package.json里面再封装一个命令。如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&符号。如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。用户执行npm run build的时候，会自动按照下面的顺序执行。因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用$npm_package_name和$npm_package_version取到这两个值。上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。下面是另外一个例子。上面代码中，npm_package_scripts_install变量的值等于foo.js。然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。注意，package.json里面的config对象，可以被环境变量覆盖。上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。最后，env命令可以列出所有环境变量。配置多个命令命令行入口一定加上：",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/npm"
      },
      {
        "module": "Tools",
        "title": "Lerna多项目管理",
        "introduction": "为了避免lerna版本不一致，所以讲lerna安装为项目依赖，而不是全局安装这将创建lerna.json配置文件和packages文件夹集中模式（默认模式）模块发布新版本时，都会升级到leran.json里编写的version字段，这是Babel目前使用的模式。如果要自动将所有包版本绑定在一起，请使用此选项。这种方法的问题是任何包中的重大更改都将导致所有包具有新的主要版本独立模式模块发布新版本时，会逐个询问需要升级的版本号，基准版本为它自身的package.json，如果需要各个组件维护自身的版本号，那么就使用independent模式，只需要去配置leran.json即可。version：存储库的当前版本。npmClient：指定运行命令的特定客户端的选项（也可以基于每个命令指定）。也可是是yarn使用yarn运行所有命令。默认为npm。command.publish.ignoreChanges：lernam publish会检查packages目录下哪些包的文件有更新，这个配置可以忽略某些文件的修改避免发布新版本。例如：修复README.md拼写错误command.bootstrap.ignore：忽略执行lerna bootstrap命令时候安装的一些包command.bootstrap.npmClientArgs：字符串数组,直接传递给npm install,作为参数. 在lerna bootstrap命令期间command.bootstrap.scope：一组匹配模式,限制运行时安装哪些包,在lerna bootstrap命令期间。packages：指定项目包默认项目都在packages目录下，你也可以把项目包放在别的目录，然后重新定义packages字段安装资源包到项目依赖安装资源包到所有项目安装资源包到指定项目安装资源包到指定规则的项目里面将本地存在相互依赖的包链接在一起，然后安装剩余依赖的包运行时此命令将：在所有的项目下执行npm install安装所有的资源包链接npm link当前目录下所有的项目执行已经安装资源包的项目npm run prepublish执行已经安装资源包的项目npm run prepare执行此命令，将执行以下操作标记上一个版本以来已更新的包每个项目package.json下面有一个gitHead标识（这个字段的值是从git暂存区取得，所以每次代码都要git commit之后才有效，否则就会报没有资源包需要更新版本）提示以及选择版本号修改项目的版本(version)以及其它元数据比如gitHead提交(git commit)这些更改推送到git远程服务器--amend使用此标记运行时，将跳过git push并保留当前提交的更改，而不是新增一个修改(没有此标记时会提交一个新的commit信息然后推送到远程服务器)#--commit-hooks提交版本更改时是否执行git钩子(git commit hooks)，默认是true，可以通过--no-commit-hooks禁用--conventional-commits提交版本的时候，直接确定版本不用选择版本(加0.1)，并生成CHANGELOG创建一个新的项目在开发之前，肯定是需要先安装各种eslint、prettier、commit-lint等等规范化库的，我们为啥要把一堆package放到一个仓库？其中一个原因不就是为了直接复用一套规范文件么。所以各种lint文件肯定是安装到项目全局的，这时如果使用lerna的安装命令:就会发现一个问题，每个package都被单独安装了eslint，这明显是不合适的，既然是同一个项目，安装多次同一个模块算个什么事？然后我们发现，lerna有提到如果你想只安装一次，那么可以把这些依赖写到每个package的package.json中，然后回到根目录运行:bootstrap是learna一键为所有package安装依赖的命令，如果加上了--hoist参数，那么就是告诉lerna，把所有依赖全部安装到根目录中，然后分别在各自的文件夹中创建软连接指向对应的模块实际路径。从解决问题的眼光来看，确实解决了重复安装的问题，不过所有模块都装到根目录混杂在一起，这让强迫症心里很不舒服，我们希望的其实是只有lint这些公共库提取出来，其他的他们自己的依赖放到他们自己的文件夹中。\n 在参考了Babel仓库的做法后，明白了。因为node自身在查找模块的时候有向父级目录查询的操作，所以其实软连接什么的并不需要，甚至都不需要lerna，我们直接这样便直接将eslint安装到了根目录中，由于层级高，所以子目录都会受到lint规则的约束。同样，为此安装好husky等等基本库，完成仓库的初始化。",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/lerna"
      },
      {
        "module": "Tools",
        "title": "Mac使用技巧",
        "introduction": "Mac自带的录屏和截图，图片更清晰，视频也更清晰",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/MacSkitll"
      },
      {
        "module": "Tools",
        "title": "markdown文件编写树形目录",
        "introduction": "",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/markdownTree"
      },
      {
        "module": "Tools",
        "title": "webpack错误收集",
        "introduction": "比如add-asset-html-webpack-plugin插件就要放在html-webpack-plugin之后这是因为所有编译出来的脚本可以有多种规范(libraryTarget)：var， 'commonjs2'那么要在dll配置里面设置输出规范然后要在DllReferencePlugin里面设置接收哪种规范",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/webpackErrors"
      },
      {
        "module": "Tools",
        "title": "常用css代码片段",
        "introduction": "用法：",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/css"
      },
      {
        "module": "Tools",
        "title": "git原理",
        "introduction": "比如说添加了两个新的文件，并且文件内容不相同可以通过git cat-file查看二进制文件的原始内容通过git ls-files可以查看暂存区的内容，包括二进制对象名通过git status命令产生更可读的结果：前面保存对象的时候，只是保存单个文件，并没有记录文件之间的目录关系（哪个文件在哪里）。 生成一个Git对象。也保存在.git/objects目录里面将目录树对象写入版本历史，将元数据和目录树，一起生成一个Git对象(这就是所谓的生成快照)所谓分支（branch）就是指向某个快照的指针，分支名就是指针名。哈希值是无法记忆的，分支使得用户可以为快照起别名。而且，分支会自动更新，如果当前分支有新的快照，指针就会自动指向它。比如master分支就是有一个叫做master指针，它指向的快照就是master分支的当前快照。用户可以对任意快照新建指针。比如，新建一个fix-typo分支，就是创建一个叫做fix-typo的指针，指向某个快照。所以，Git新建分支特别容易，成本极低。Git有一个特殊指针HEAD， 总是指向当前分支的最近一次快照。另外，Git还提供简写方式，HEAD^指向HEAD的前一个快照（父节点），HEAD~6则是HEAD之前的第6个快照。每一个分支指针都是一个文本文件，保存在.git/refs/heads/目录，该文件的内容就是它所指向的快照的二进制对象名（哈希值）。",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/gitTheory"
      },
      {
        "module": "Tools",
        "title": "常用git",
        "introduction": "git reset除了在当前分支上操作，你还可以通过传入这些标记来修改你的缓存区或工作目录：--soft – 缓存区和工作目录都不会被改变\n--mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响\n--hard – 缓存区和工作目录都同步到你指定的提交\n把这些标记想成定义 git reset 操作的作用域就容易理解多了。reset将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交。使用reset就会有一个问题，本地的快照要慢于服务器上面的快照，直接push的时候，就需要pull代码，就又会把回退过后的代码拉下来。如果是自己的功能分支，可以才用强制推送(--force)",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/oftenGit"
      },
      {
        "module": "Tools",
        "title": "生成项目树状结构的tree命令",
        "introduction": "tree是一个能列出递归目录的命令，以图形显示驱动器或路径的文件夹结构，可以生成命令树。Windows和Linux都有，mac没有原生支持，需要安装tree。生成如下结构：生成如下结构：生成结构如下：",
        "moduleIntro": "项目管理工具",
        "path": "/Tools/treeCommand"
      }
    ]
  },
  {
    "module": "Packages",
    "title": "插件包",
    "views": [
      {
        "module": "Packages",
        "title": "命令行插件包",
        "introduction": "yargs for github   yargs for 阮一峰commander for github commander fro 中文gluegun 方便的定义命令行命令和参数shelljscash可以使用ES6blessed-contribsparkly 命令行生成梯形图chalkgradient-string生成渐变色的文字Jsome漂亮的输出JSON对象colors比如清空控制台，来渲染进度，或者是动画listrnode-multispinnerfiguresboxen\n控制台创建边框node-bcatbrowser-runscatnode-hcatbpipe一个字符串常量,定义操作系统相关的行末标志:\\n 在 POSIX 系统上\\r\\n 在 Windows系统上json-templater 模板解析字符串或者json文件package.jsonbin.js例如下面的vue-cli打包出来用列表的形式显示出各个资源包的大小",
        "moduleIntro": "插件包",
        "path": "/Packages/CommandLine"
      },
      {
        "module": "Packages",
        "title": "Vue插件包",
        "introduction": "实用好看的Loading包vue-loading-spinner快速支持Emoji  vue-emoji-picker",
        "moduleIntro": "插件包",
        "path": "/Packages/vue"
      },
      {
        "module": "Packages",
        "title": "工具包",
        "introduction": "revealHTML里面可以直接插入markdown，来制作漂亮的幻灯片，来做演示demopinyin",
        "moduleIntro": "插件包",
        "path": "/Packages/tools"
      }
    ]
  },
  {
    "module": "javascript",
    "title": "原生js",
    "views": [
      {
        "module": "javascript",
        "title": "JS技巧",
        "introduction": "",
        "moduleIntro": "原生js",
        "path": "/javascript/skill"
      },
      {
        "module": "javascript",
        "title": "对象相关知识",
        "introduction": "in 操作符hasOwnProperty方法可以创建一个干净的对象默认申请一个对象，会继承很多最基础的Object上面的方法，比如hasOwnProperty等方法定义：proto: 新创建对象的原型对象propertiesObject:可选。 要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。只要proto不为null，都不是一个纯净的对象for...in包括原型上的属性（所以一般配合hasOwnProperty使用）只遍历可枚举的属性不包含Symbol属性Object.getOwnPropertyNames返回自身的所有属性名称（不包括原型上的属性）包括不可枚举的属性不包含Symbol属性Object.keys返回自身的所有属性名称（不包括原型上的属性）不包括不可枚举的属性不包含Symbol属性Object.values返回自身的所有属性值（不包括原型上的属性）不包括不可枚举的属性值不包含Symbol属性Object.entries返回自身的所有属性名称和属性值的集合（不包括原型上的属性）不包括不可枚举的属性值不包含Symbol属性Object.getOwnPropertySymbols返回自身的Symbol属性（不包括原型上的属性）包括不可枚举的属性Reflect.ownKeys返回自身的所有属性名称和属性值的集合（不包括原型上的属性）包括不可枚举的属性值包含Symbol属性Reflect.enumerate返回自身的所有属性名称和属性值的集合（包括原型上的属性）不包括不可枚举的属性值不包含Symbol属性",
        "moduleIntro": "原生js",
        "path": "/javascript/object"
      },
      {
        "module": "javascript",
        "title": "抽象语法树",
        "introduction": "抽象语法树是js代码另一种结构映射，可以将js拆解成AST，也可以把AST转成源代码。这中间的过程就是我们的用武之地。 利用 抽象语法属(AST) 可以对你的源代码进行修改、优化，甚至可以打造自己的编译工具。比如你看到这里用了var不顺眼，你可以分分钟改成let。 有点类似babel的功能。我们可以大致的想一下如果亲自实现把js代码转换成结构化的数据我们应该怎么做？\n就像是小时候拆解自己的玩具，在进行组合，或者像老妈给我们做的可口的饭菜，把原材料进行加工处理。\n对于ast，可能我们会想到使用字符串处理、正则匹配等方法，如果对简单的代码处理我们是可以实现的。\n但是如果能够对随意的一段代码进行处理那就需要考虑非常多的情况。具体如何实现咱们不必过于纠结，这也不是重点。\n但最终的实现里我们能想到方法基本都会被用到。我们可以简化理解，也就是对js代码经过了一系列的加工处理，变成了一盘好吃的饭菜。\n这个做菜过程可能较为复杂，所以我们需要用现成的做菜方法，直接拿过来用就可以了。比如某某浓汤宝，好喝的可以评论下，我打算试试。\n所以我们需要用到esprima、UglifyJS等库，做菜的方法不止一种，所以会存在很多这样的三方库，而我们会使用其中一种就可以了把 == 改成全等 ===基础方法",
        "moduleIntro": "原生js",
        "path": "/javascript/ast"
      },
      {
        "module": "javascript",
        "title": "void用法",
        "introduction": "void运算符 对给定的表达式进行求值，然后返回undefinedLet expr be the result of evaluating UnaryExpression.Call GetValue(expr).Return undefined.重点在于无论void后的表达式是什么，void操作符都会返回undefined因为undefined在javascript中不是保留字。换言之，你可以写出：对的，你可以在一个函数上下文内以undefined做为变量名，于是在这个上下文写的代码便只能通过从全局作用域来取到undefined，如：但要注意的是，即便window, GLOBAL仍然可以在函数上下文被定义，故从window/GLOBAL上取undefined并不是100%可靠的做法。如：于是，采用void方式获取undefined便成了通用准则。如underscore.js里的isUndefined便是这么写的：除了采用void能保证取到undefined值以外，还有其它方法吗？有的，还有一种方式是通过函数调用。如AngularJS的源码里就用这样的方式：注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。这是什么意思？这表示无论void右边的表达式是什么，都要对其求值。从执行情况可以看出，无论是普通访问girl.whenMarry，还是void girl.whenMarry都会使她的happiness--。而如果把void换成delete操作符写成delete girl.whenMarry，她的happiness就不会减了，因为delete操作符不会对girl.whenMarry求值。立即调用的函数表达式在使用立即执行的函数表达式时，可以利用void运算符让 JavaScript 引擎把一个function关键字识别成函数表达式而不是函数声明（语句）。JavaScript URIs当用户点击一个以javascript: URI 时，它会执行URI中的代码，然后用返回的值替换页面内容，除非返回的值是undefined。void运算符可用于返回undefined。例如：",
        "moduleIntro": "原生js",
        "path": "/javascript/void"
      },
      {
        "module": "javascript",
        "title": "错误搜集",
        "introduction": "当代码中的 promise reject 的时候，onerror 是捕获不到异常的。对于promise reject 的异常，除了对每个用到 promise 的地方都加上 catch 之外，我们还应该在全局环境下进行一个兜底。我们可以监听全局 unhandledrejection 事件：如果要阻止异常输出到控制台上，可以加上 e.preventDefault()。",
        "moduleIntro": "原生js",
        "path": "/javascript/errorCollect"
      },
      {
        "module": "javascript",
        "title": "暂时性死区",
        "introduction": "请思考下面这段代码，结果会是什么？如果了解变量提升，那么很容易就会知道结果是undefined而在ES6中，会出现什么情况呢？我们看到，在第一段代码中，只把 var 改成 let 代码就会报错:ReferenceError: a is not defined原因就是我们忽略了let的暂时性死区（ temporal dead zone，简称TDZ ）先来看看ES6标准中对let/const声明中的解释 第13章，有如下一段文字：The variables are created when their containing Lexical Environment is instantiated but may not be accessed inany way until the variable’s LexicalBinding is evaluated.当然这段话我看完也很懵，查阅了一些帖子，翻译成人话就是：当程序的控制流程在新的作用域（module function 或 block 作用域）进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。如果你还是记不住，那么只需理解下面这句话即可：ES6规定，let/const命令会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。\n总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。\n这在语法上，称为暂时性死区（ temporal dead zone，简称 TDZ）。TDZ也意味着typeof不再是一个百分之百安全的操作。我们看下面这段代码，在没有let之前，typeof运算符是百分之百安全的，不会报错。\n现在这一点不成立了。",
        "moduleIntro": "原生js",
        "path": "/javascript/temporalDeadZone"
      },
      {
        "module": "javascript",
        "title": "typeOf以及Instanceof的使用",
        "introduction": "typeof其实就是判断参数是什么类型的实例，就一个参数，用例：typeof A\n返回值：1. 对于基本类型除了null以外，全都返回正确的数据类型也就是说下面这些数据类型，可以直接判断2. null返回 object 类型3. 对于引用类型除了function以外，全都返回object也就是说对于数组或者对象都会返回object4. 对于function，返回function\n也就是说对于function也可以直接判断instanceof 是用来判断 A 是否是 B的实例，表达式为 A instanceof B，返回Boolean类型从上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们来看几个例子：JS万物皆对象的思想：我们来分析一下 []、Array、Object 三者之间的关系：从 instanceof 能够判断出 [].proto 指向 Array.prototype，而 Array.prototype.proto 又指向了Object.prototype，最终 Object.prototype.proto 指向了 null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。答：function true true答：这里需要注意变量声明提升，所以上面代码等效于：这时候，typeof name 就等于 undefined，所以输出结果为 Hi~Jartto。",
        "moduleIntro": "原生js",
        "path": "/javascript/typeOfInstanceof"
      },
      {
        "module": "javascript",
        "title": "原型以及原型链",
        "introduction": "###1. 原型是什么每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性。###2. 每个函数都有一个prototype属性###3. 每个对象(除了null以外)都有一个_proto_属性每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。让我们用一张图表示构造函数和实例原型之间的关系：\n在这张图中我们用 Object.prototype 表示实例原型。那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：这是每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。为了证明这一点,我们可以在火狐或者谷歌中输入：于是我们更新下关系图：原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。为了验证这一点，我们可以尝试：所以再更新下关系图：\n综上我们已经得出：了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。举个例子：在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。但是万一还没有找到呢？原型的原型又是什么呢？在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 proto 指向构造函数的 prototype ，所以我们再更新下关系图：\n那 Object.prototype 的原型呢？null，我们可以打印：最后一张关系图也可以更新为：\n",
        "moduleIntro": "原生js",
        "path": "/javascript/prototype"
      },
      {
        "module": "javascript",
        "title": "理解浏览器的事件循环",
        "introduction": "主线程在执行完同步任务之后，就会去检查微任务队列(microTask)，如果微任务队列(mircoTask)为空，就会检查宏任务(Task)，如果微任务队列(microTask)不为空，就会一次性执行完队列里面所有的微任务。\n每次单个宏任务执行完毕后，就会检查微任务队列，如果队列有任务，就会执行完所有的微任务。执行微任务队列的代码微任务fn1加入主线程开始执行，打印promise1，返回一个新的Promise值为undefined，加入微任务fn1执行完毕，从微任务队列移除掉，fn1作为同步任务执行完毕，检查微任务队列里面有fn2,于是将fn2加入主线程，开始执行，打印promise2，主线程执行完毕后，检查微任务队列，发现微任务没有了，就开始检查宏任务移除执行完毕的fn2，加入主线程的宏任务开始执行，打印setTimeout，所有的代码执行完毕Task宏任务有：microTask微任务有：:::tip\n浏览器希望为开发人员提供一种监控DOM变化的方法，但是如果发生下面的情况，你是希望想听到一次，还是100次呢\n::::::tip\n答案肯定就是一次了，这里浏览器就创建了一个新的队列:微任务(microTask),他承诺你在当前js执行完毕，也就是栈空的时候就会执行所有的微任务，微任务可能发生在事件循环的任何地方，比如在requestAnimationFrame回调里面启动一个微任务，这个微任务就会在requestAnimationFrame回调栈空之后，渲染之前执行，也说明了如果有一个一直执行的微任务队列，那么浏览器也就会卡死\n:::看个例子:我们给一个DOM绑定两个事件:::tip\n当我们点击DOM的时候，会打印2,1,4,3\n:::但是如果是js触发的呢:::tip\njs触发的时候，就会打印2,4,1,3\n::::::warning\njs调用触发的时候，两次回调没有执行完，dom.click()这里的javascript不会从栈里面移除，导致微任务一直不能触发，最后才会触发\n:::Tasks, microtasks, queues and schedules一次弄懂Event Loop深入探究 eventloop 与浏览器渲染的时序问题",
        "moduleIntro": "原生js",
        "path": "/javascript/eventLoop"
      },
      {
        "module": "javascript",
        "title": "关于requestAnimationFrame的总结",
        "introduction": "可以看出requestAnimationFrame是一个宏任务，Promise是一个微任务。弹窗动画将不会执行一定可以触发弹窗动画还有一种做法是在requestAnimationFrame强制触发一次回流",
        "moduleIntro": "原生js",
        "path": "/javascript/requestAnimationFrame"
      },
      {
        "module": "javascript",
        "title": "数组的操作",
        "introduction": "从一个类似数组或可迭代对象中创建一个新的数组实例。所谓ArrayLike对象指具有数组某些行为的对象，表现出来的特征就是具有length属性。",
        "moduleIntro": "原生js",
        "path": "/javascript/Array"
      },
      {
        "module": "javascript",
        "title": "退出循环",
        "introduction": "以上几种都可以使用break,continue,return等方法跳出循环find() 方法返回数组中满足提供的测试函数的第一个元素的值，只要循环中返回true，就会退出遍历findIndex() 方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1some() 方法测试是否至少有一个元素通过由提供的函数实现的测试，只要循环中返回true，就会退出遍历，最终返回的是个Boolean类型的值",
        "moduleIntro": "原生js",
        "path": "/javascript/breakLoop"
      },
      {
        "module": "javascript",
        "title": "数组的高级操作",
        "introduction": "arr.sort((a, b) => b - a)回调函数执行三次回调函数的返回值，决定了哪个在前面，哪个在后面，返回true说明a在后面，b在前面",
        "moduleIntro": "原生js",
        "path": "/javascript/arrayAdvanced"
      }
    ]
  },
  {
    "module": "bug",
    "title": "项目中遇到的坑",
    "views": [
      {
        "module": "bug",
        "title": "babel无法编译node_modules下面的ES6",
        "introduction": "通过配置configFile来指定babel.config.js配置项，而不是.babelrc文件babel7默认的编译顺序，是寻找文件最近的.babelrc配置来编译babel解释设置webpack读取npm包的时候，不从module指向去解析，而是从main指向去解析文件设置alias",
        "moduleIntro": "项目中遇到的坑",
        "path": "/bug/webpack"
      },
      {
        "module": "bug",
        "title": "hybrid存在的一些问题",
        "introduction": "通过historyapi去解决",
        "moduleIntro": "项目中遇到的坑",
        "path": "/bug/hybrid"
      },
      {
        "module": "bug",
        "title": "vue相关的问题",
        "introduction": "前提条件是，路由参数是number类型，才会有这些问题1、通过query传递的方式，页面通过vue-router的方式进入的时候(push,back,go)这些方法进入的时候，页面参数还是Number类型，别的方式进入(F5刷新，window.location.href，浏览器返回等方式进入)都会变成String类型。2、通过params的方式进入，始终都是String类型3、通过props的方式进入，始终都是String类型由于params方式，是把参数放到内存里面，所以刷新页面后参数会丢失，但是可以设置动态路由的方式，动态路由的参数，也可以通过params方式去读取参数，这样就不会丢失了",
        "moduleIntro": "项目中遇到的坑",
        "path": "/bug/vueFix"
      },
      {
        "module": "bug",
        "title": "打包dll问题",
        "introduction": "1、dll的context不能带项目名称，因为项目名称这个文件夹，也许在服务器上打包环境并不存在2、npm和cnpm的区别导致的，cnpm安装包的时候，会生成带下划线的目录(_vue)等目录，项目中引入的时候也会这样，所以npm安装的包和cnpm安装的包，打包出来的dll会不一样。",
        "moduleIntro": "项目中遇到的坑",
        "path": "/bug/dll"
      }
    ]
  },
  {
    "module": "Foods",
    "title": "干货",
    "views": [
      {
        "module": "Foods",
        "title": "浏览器往返缓存解决方案",
        "introduction": "往返缓存（Back/Forward cache，下文中简称bfcache）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到bfcache中；当用户点击后退按钮的时候，将页面直接从bfcache中加载，节省了网络请求的时间。但是bfcache的引入，导致了很多问题。下面，举一个我们遇到的场景：页面A是一个任务列表，用户从A页面选择了“任务1：看新闻”，点击“去完成”跳转到B页面。当用户进入B页面后，任务完成。此时用户点击回退按钮，会回退到A页面。此时的A页面“任务1：看新闻”的按钮，应该需要标记为“已完成”，由于bfcache的存在，当存入bfcache时，“任务1”的按钮是“去完成”，所以此时回来，按钮也是“去完成”，而不会标记为“已完成”。既然bug产生了，我们该如何去解决它？很多文章都会提到unload事件，但是我们实际进行了测试发现并不好用。于是，为了解决问题，我们的bfcache探秘之旅开始了。在检索page cache in chromium的时候，我们发现了这个issue：bugs.chromium.org/p/chromium/issues/detail?id=229605。里面提到 chromium（chrome的开源版本）在很久以前就已经将PageCache（即bfcache）这部分代码移除了。也就是说现在的chrome应该是没有这个东西的。可以确定的是，chrome以前的版本中，bfcache的实现是从webkit中拿来的，加上我们项目目前面向的用户主体就是 iOS + Android，iOS下是基于Webkit，Android基于chrome（且这部分功能也是源于webkit）。因此追溯这个问题，我们只要专注于研究webkit里bfcache的逻辑即可。同样通过上文中描述的commit记录，我们也很快定位到了PageCache相关逻辑在Webkit中的位置：webkit/Source/WebCore/history/PageCache.cpp。该文件中包含的两个方法引起了我们的注意：canCachePage和canCacheFrame。这里的Page即是我们通常理解中的“网页”，而我们也知道网页中可以嵌套<frame>、<iframe>等标签来置入其他页面。所以，Page和Frame的概念就很明确了。而在canCachePage方法中，是调用了canCacheFrame的，如下：源代码链接：webkit/Source/WebCore/history/PageCache.cpp因此，重头戏就在canCacheFrame了。canCacheFrame方法返回的是一个布尔值，也就是其中变量isCacheable的值。那么，isCacheable的判断策略是什么？更重要的，这里面的策略，有哪些是我们能够利用到的。注意到这里的代码：源代码链接：webkit/Source/WebCore/history/PageCache.cpp很明显canSuspendActiveDOMObjectsForDocumentSuspension是一个非常重要的方法，该方法中的重要信息见如下代码：源代码链接：webkit/Source/WebCore/dom/ScriptExecutionContext.cpp在这一部分，可以看到他调用每一个ActiveDOMObject的canSuspendForDocumentSuspension方法，只要有一个返回了false，canSuspend就会是false（Suspend这个单词是挂起的意思，也就是说存入bfcache对于浏览器来说就是把页面上的frame挂起了）。接下来，关键的ActiveDOMObject定义在：webkit/Source/WebCore/dom/ActiveDOMObject.h，该文件这部分注释，已经告诉了我们最想要的信息。The canSuspendForDocumentSuspension() function is used by the caller if there is a choice between suspending and stopping. For example, a page won't be suspended and placed in the back/forward cache if it contains any objects that cannot be suspended.canSuspendForDocumentSuspension用于帮助函数调用者在“挂起（suspending）”与“停止”间做出选择。例如，一个页面如果包含任何不能被挂起的对象的话，那么它就不会被挂起并放到PageCache中。接下来，我们要找的就是，哪些对象是不能被挂起的？在WebCore目录下，搜索包含canSuspendForDocumentSuspension() const关键字的.cpp文件，能找到48个结果。大概看了一下，最好用的objects that cannot be suspended应该就是Worker对象了，见代码：源代码链接：webkit/Source/WebCore/workers/Worker.cpp业务上添加如下代码：",
        "moduleIntro": "干货",
        "path": "/Foods/BackForwardCache"
      },
      {
        "module": "Foods",
        "title": "程序里面的缩写",
        "introduction": "PRPull Request 拉去请求LGTMLooks Good To Me 代码已经review，可以合并(朕知道了)SGTMSounds Good To Me 和👆的差不多，也是已经通过review的意思WIPWork In Progress 传说中提PR的最佳实践是，如果你有个改动很大的PR，可以在写了一部分的情况下先提交，但是在标题里写上WIP，以告诉项目维护者这个功能还未完成，方便维护者提前review部分提交的代码PTALPlease Take A Look 你来瞅瞅？用来提示别人来看一下TBRTo Be Review 提示维护者进行reviewTL;DRToo Long;Didn't Read 太长懒得看。TBDTo Be Done(or Defined/Discussed/Decided/Determined) 根据语境不同意义有所不同，但一般都是还没搞定的意思i18nInternationalization 国际化l10nLocalization 本地化；定位m17nMultilingualization 多语言化c14nCanonicalization 标准化；规范化i14yInteraperability 互用性；互操作性P13nPersonalization 个性化v12nVirtualization 虚拟化K8sKubernetes 基于Docker容器云技术c10k Problem10 thousand clients",
        "moduleIntro": "干货",
        "path": "/Foods/LGTM"
      },
      {
        "module": "Foods",
        "title": "浏览器解析过程",
        "introduction": "html文档的加载与页面的首次渲染：再谈 load 与 DOMContentLoaded从输入URL到页面加载的过程？",
        "moduleIntro": "干货",
        "path": "/Foods/browserRender"
      },
      {
        "module": "Foods",
        "title": "页面事件",
        "introduction": "HTML 页面的生命周期有三个重要事件：每个事件都是有用的：我们探讨一下这些事件的细节。DOMContentLoaded 事件发生在 document 对象上。我们必须使用 addEventListener 来监听它：例如：在示例中， DOMContentLoaded 处理器在文档加载时运行，而不是等到页面被加载时运行。因此 alert 显示大小为零。初识 DOMContentLoaded 事件时，觉得它比较简单。DOM 树已经准备好了 —— 这是事件。但却没有什么特别之处。当浏览器开始加载 HTML 并在文本中遇到 <script>...</script> 时，就会停止构建 DOM。它必须立即执行脚本。因此 DOMContentLoaded 只有在所有此类脚本被执行后才会发生。额外的脚本（带有 src）也会促使 DOM 构建在加载和执行过程时暂停。因此 DOMContentLoaded 也会等待外部脚本。唯一的例外是具有 async 和 defer 属性的外部脚本。它们告诉浏览器可以继续解析文档而不必等待脚本解析和执行。因此用户可以在脚本完成加载之前就看到页面，这对性能来说是有好处的。外部样式不会影响 DOM，因此 DOMContentLoaded 无需等待它们。但有一个陷阱：如果在样式之后有一个脚本，那么该脚本必须等待样式被执行：原因是脚本可能希望获取如上述示例所描述的元素坐标和其他与样式相关的属性。当然，它必须等待样式被加载。当 DOMContentLoaded 等待脚本时，它也在等待它们之前的样式。Firefox、Chrome 和 Opera 都会在 DOMContentLoaded 中自动填写表单。比如，如果页面有一个带有登录和密码的表单，并且浏览器记住了这些值，那么在 DOMContentLoaded 上，它就可以尝试自动填写它们（如果用户允许）。因此如果 DOMContentLoaded 被长加载脚本延迟，那么自动填写也在等待。你可能在某些站点上（如果你使用浏览器自动填写）—— 登录/密码字段将不会立即自动填写，在页面被完全加载前会出现延迟。这实际上是延迟到 DOMContentLoaded 事件。为外部脚本使用 async 和 defer 的一个好处是 —— 它们不会阻塞 DOMContentLoaded，而且也不会延迟浏览器的自动填写。当包括样式、图像和其他资源的页面被全部加载时， load 事件就会在 window 对象上被触发。以下示例正确地显示了图像大小，因为 window.onload 等待了所有的图像：当访问者离开页面时， unload 事件会在 window 上被触发。我们可以在那里做一些不涉及延迟的事件，比如关闭相关的弹出窗口。但我们不能取消跳转到另一个页面的事件。因此我们需要使用另一个事件 —— onbeforeunload。如果访问中启动了离开页面的导航或试图关闭窗口， beforeunload 处理器将要求提供更多的确认。它可能会返回一个带有问题的字符串。从历史上看，浏览器通常会显示它，但到目前为止，只有一些浏览器这样做。这是因为某些站长滥用了这个事件处理器，显示了误导和恶意的信息。你可以通过运行这段代码，然后重新加载页面来进行尝试。你也可以单击以下 <iframe></iframe> 中的按钮来设置处理器，然后单击链接：如果在加载文档之后设置 DOMContentLoaded 处理器会发生什么？很自然地，它从未运行过。在某些情况下，我们不确定文档是否已经准备就绪，比如一个具有 async 属性的脚本加载并异步运行。取决于网络，它可能在文档完成之前加载和执行，或者在此之后，我们无法确定。因此，我们应该能够知道文件的当前状态。document.readyState 属性为我们提供了一些关于它的信息。有三个可能的值：因此我们检查 document.readyState 并设置一个处理器，或在代码准备就绪时立即执行它。就像这样：有一个 readystatechange 事件，当状态发生变化时触发，因此我们可以打印如下所有这些状态：readystatechange 事件是跟踪文档加载状态的另一种机制，它很早就存在了。现在则很少被使用，但我们还是需要来讨论一下它的完整性。readystatechange 在其他事件中的地位？要查看时间，这里有一个带有 <iframe></iframe>、 <img> 和记录事件的处理器：典型输出：方括号中的数字表示发生这种情况的大致时间。实际时间会长一些，但标记为相同数字的事件几乎是同时发生的（± 几毫秒）。页面生命周期事件：页面生命周期：DOMContentLoaded、load、beforeunload 和 unload浏览器、页面",
        "moduleIntro": "干货",
        "path": "/Foods/pageLifeCircle"
      },
      {
        "module": "Foods",
        "title": "事件捕获与冒泡",
        "introduction": "一般监听事件第三个参数useCapture，表示是否在捕获阶段，设置处理器要在捕获阶段捕获事件，我们需要将addEventListener的第三个参数设置为true。最后一个参数是可选的，有两个可能的值：这个参数决定了，事件处理器的执行顺序：",
        "moduleIntro": "干货",
        "path": "/Foods/eventCapturePropagation"
      },
      {
        "module": "Foods",
        "title": "字体文件优化加载和渲染",
        "introduction": "默认情况下，在构建渲染树之前会延迟字体请求，这可能会导致文本渲染延迟字体延迟加载带有一个可能会延迟文本渲染的重要隐藏影响：浏览器必须构建渲染树（它依赖 DOM 和 CSSOM 树），然后才能知道需要使用哪些字体资源来渲染文本。 因此，字体请求的处理将远远滞后于其他关键资源请求的处理，并且在提取资源之前，可能会阻止浏览器渲染文本。网页内容的首次绘制（可在渲染树构建后不久完成）与字体资源请求之间的“竞赛”产生了“空白文本问题”，出现该问题时，浏览器会在渲染网页布局时遗漏所有文本\n。大部分浏览器在等待下载网络字体时会执行最大超时策略，超时之后将使用回退字体。 不过，各个浏览器的执行方式并不相同：也就说怎么自定义这种默认行为您的页面很有可能需要您事先在知道的网址上托管特定的网页字体，如果确实如此，您可利用新的网络平台功能：<link rel=\"preload\">然预加载可以增加网络字体在页面内容渲染时可用的可能性，但并不保证一定如此(因为下载成功有可能在构建渲染树之后)。 您仍需要考虑所渲染的文本使用了尚未可用的 font-family 时浏览器的行为。为确保之后的一致性，CSS 工作组已提议采用新的 @font-face 描述符 font-display，以及用于控制可下载字体在加载前如何渲染的相应属性。与某些浏览器目前实施的现有字体超时行为相似，font-display 将字体下载生命周期分为三个主要期间：了解这些期间后，您即可使用 font-display，根据是否或何时下载字体，决定渲染字体的方式使用 font-display若要使用 font-display 属性，则为其添加 @font-face 规则：font-display 当前支持以下范围的值： auto | block | swap | fallback | optional。为此，浏览器将创建指标与所选字体相似的匿名字体，但所有字形皆不含“墨水”。只有在必须以特定字样渲染文本以使页面可用时，才应使用此值。font-display 在许多现代浏览器中获得采用。 随着这种属性的实施范围越来越广，浏览器采取一致行为指日可待开发者可以将 <link rel=\"preload\"> 与 font-display 配合使用，以很好地控制字体加载与渲染，而不会增加很多开销。 但是，如果您需要进一步自定义，而且愿意承担运行 JavaScript 所引入的开销，还有一个选项可供选择。Font Loading API 提供一种脚本编程接口来定义和操纵 CSS 字体，追踪其下载进度，以及替换其默认延迟下载行为。 例如，如果您确定需要特定字体变体，您可以对其进行定义并指示浏览器立即提取字体资源：此外，由于您可以检查字体状态（通过 check() 方法）并追踪其下载进度，因此您还可以为在网页上渲染文本定义自定义策略：最重要的是，您还可以混用和匹配上述策略来适应网页上的不同内容。 例如，在获得字体前延迟某些部分的文本渲染；使用回退字体，然后在字体下载完成后进行重新渲染；指定不同的超时等等。注：在某些浏览器上，Font Loading API 仍处于开发阶段。 您可以考虑使用 FontLoader polyfill 或webfontloader 库来提供类似功能，不过附加的 JavaScript 依赖关系会产生更多开销。:::warning\n在 src 列表中优先列出 local()：在 src 列表中首先列出local('Font Name')可确保不会针对已安装的字体发出 HTTP 请求\n:::",
        "moduleIntro": "干货",
        "path": "/Foods/fontFace"
      },
      {
        "module": "Foods",
        "title": "chrome的第一帧渲染",
        "introduction": "First paint 直译过来的意思就是浏览器第一次渲染(paint)，在First paint之前是白屏，在这个时间点之后用户就能看到（部分）页面内容。所以研究这个First Paint的触发时机对于优化浏览器页面的首屏渲染时间有很重要的作用。:::tip\n现在浏览器有做优化，在解析HTML开始阶段，就会提取所有标记性标签，识别外链资源，开始阶段并发的发出这些资源的下载请求\n:::根据最新版的chrome调试performance可以发现First Paint的加载流程应该是这样：\n:::tip自己的总结就是：所有的css资源加载完毕，css树构建完毕，会根据已经构建的局部DOM树，生成一次渲染树，paint一次完整的总结是：\n:::tip\n浏览器会提前渲染body中第一个脚本前的内容（我们就把body中的第一个外链脚本叫做【第一脚本】吧），并且第一脚本还会在FP之后才执行。所以结合之前得出的结论，在CSSOM准备就绪之后，浏览器会提前渲染第一脚本前的内容\n:::FP发生在body中第一个script脚本之前的CSS解析和JS执行完成之后。换句话说就是第一脚本之前的DOM和CSSOM准备就绪之后，便会着手渲染第一脚本前的内容。:::warning\n如果第一脚本前的JS和CSS加载完了，body中的脚本还未下载完成，那么浏览器就会利用构建好的局部CSSOM和DOM提前渲染第一脚本前的内容（触发FP）；如果第一脚本前的JS和CSS都还没下载完成，body中的脚本就已经下载完了，那么浏览器就会在所有JS脚本都执行完之后才触发FP。\n:::",
        "moduleIntro": "干货",
        "path": "/Foods/chromeFirstPain"
      },
      {
        "module": "Foods",
        "title": "强制同步布局",
        "introduction": ":::tip\n布局是浏览器计算各元素几何信息的过程：元素的大小以及在页面中的位置。\n:::Layout的开销主要体现在：当您更改样式时，浏览器会检查任何更改是否需要计算布局，以及是否需要更新渲染树。对“几何属性”（如宽度、高度、左侧或顶部）的更改都需要布局计算。通过Performance查看Layout的影响范围以及时间渲染一帧的正常顺序应该是：:::tip\n在javascript运行时，来至上一帧的所有布局值，都是已知的，所以在当前帧里面获取布局值是最好的做法(因为浏览器的优化可能把批量的操作统一化异步布局了，下一帧读取上一帧的布局肯定是能读到的)\n::::::warning\n但是如果在当前帧的开始又更改样式，而且又需要读取这个样式，就会引发强制同步布局(为了读取到正确的样式，JavaScript 强制浏览器提前执行布局)\n::::::tip\n大部分情况下，并不需要应用样式然后查询值；使用上一帧的值就足够了。与浏览器同步（或比其提前）运行样式计算和布局可能成为瓶颈\n:::正确的做法：假设使用setTimeout或setInterval来触发JS执行并修改样式从而导致视觉变化；那么会有这样一种情况，因为setTimeout或setInterval没有办法保证回调函数什么时候执行，它可能在每一帧的中间执行，也可能在每一帧的最后执行。所以会导致即便我们能保障每一帧的总耗时小于16ms，但是执行的时机如果在每一帧的中间或最后，最后的结果依然是没有办法每隔16ms让屏幕产生一次变化。也就是说，即便我们能保证每一帧总体时间小于16ms，但如果使用定时器触发动画，那么由于定时器的触发时机不确定，所以还是会导致动画丢帧。现在整个Web只有一个API可以解决这个问题，那就是requestAnimationFrame，它可以保证回调函数稳定的在每一帧最开始触发。避免大型、复杂的布局和布局抖动前端性能优化之浏览器渲染优化 —— 打造60FPS页面让你的网页更丝滑（一）",
        "moduleIntro": "干货",
        "path": "/Foods/syncLayout"
      },
      {
        "module": "Foods",
        "title": "理解作用域链",
        "introduction": ":::tip\n这些代码块被称为词法单元(token) ，这些词法单元组成了词法单元流数组\n::::::tip\n把词法单元流数组转换成一个由元素逐级嵌套所组成的代表程序语法结构的树，这个树被称为“抽象语法树” (Abstract Syntax Tree, 简称AST)。\n::::::tip\n将抽象语法树（AST）转换为一组机器指令，也就是可执行代码，简单说，就是用来创建一个变量a，并将3这个值储存在a中。\n::::::warning:::tip例子一：函数运行的瞬间，创建一个AO (Active Object 活动对象)AO (Active Object 活动对象) 相当于载体:::tip\nAO = {}\n:::第一步，分析函数参数：:::tip\n形式参数：AO.age = undefined\n实参：AO.age = 18\n:::第二步，分析变量声明：:::tip\n// 第3行代码有var age\n// 但此前第一步中已有AO.age = 18, 有同名属性,不做任何事\n即AO.age = 18\n:::第三步，分析函数声明：:::tip\n// 第5行代码有函数age\n// 则将function age(){}付给AO.age\nAO.age = function age() {}\n:::函数声明特点：AO上如果有与函数名同名的属性,则会被此函数覆盖分析阶段最终结果是：:::tip\nAO.age = function age() {}\n:::例子二：:::tip\nAO = {}\n:::第一步，分析函数参数：:::tip\n形式参数：AO.age = undefined\n实参：AO.age = 18\n:::第二步，分析变量声明：:::tip\n// 第2行代码有var age\n// 但此前第一步中已有AO.age = 18, 有同名属性,不做任何事\n即AO.age = 18\n:::第三步，分析函数声明：:::tip\n无\n:::分析阶段最终结果是：:::tip\nAO.age = 18\n:::例子三：:::tip\nAO = {}\n:::第一步，分析函数参数：:::tip\n形式参数：AO.age = undefined\n实参：AO.age = 18\n:::第二步，分析变量声明：:::tip\n// 第2行代码有var age\n// 但此前第一步中已有AO.age = 18, 有同名属性,不做任何事\n即AO.age = 18\n:::第三步，分析函数声明：:::tip\n无\n:::分析阶段最终结果是：:::tip\nAO.age = 18\n:::2.1 age()的分析和执行:::tip\n// 分析阶段\n创建新的AO对象，AO = {}\n第一步，分析函数参数（无）\n第二步，分析变量声明（无）\n第三步，分析函数声明（无）\n分析阶段最终结果是：AO = {}\n::::::tip\nJavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到大boss:window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。\n:::",
        "moduleIntro": "干货",
        "path": "/Foods/actionScopeList"
      },
      {
        "module": "Foods",
        "title": "再谈浏览器事件循环",
        "introduction": ":::tip\n浏览器是多线程的，如网络线程，编码解码线程，加密和监控线程，GUI渲染线程等等，只不过js引擎是单线程的，所有的线程完成了页面需要监听的内容，就会回到主线程通知主线程。\n::::::tip\n下面是：事件循环正在以CPU高效的速度，运行着\n:::\n:::tip\n下面是：当有任务发生时，浏览器对事件循环说，我有一份任务要交给你来做，事件循环说：“好的，把他加到我的待办事项里面，我空闲的时候就会去做”\n:::比如下面这个例子：:::tip\n浏览器对事件循环说，我这里有两件事需要你做一下，在经过1000ms之后事件循环将callback1,callback2放到代办事项里面，在主线程执行完毕绕道穿插口的时候，正好绕道待办事项，执行一次任务，继续下次任务，再次绕道穿插口，再执行一次任务\n::::::warning\n这里需要注意的一点是：每次事件循环只会执行一个任务\n::::::tip\n浏览器的渲染又是事件循环里面的又一条弯道了\n:::看个例子：:::tip\n这段代码我们可能会担心元素发生闪烁，因为先拼接DOM，然后再设置元素隐藏，实际上则不会，因为渲染任务会在这段js执行完毕之后，才会进入渲染弯道，只会paint一次\n:::看个例子：比如说页面上有个gif图片第一种情况是这样的: 会造成gif停止第二种情况是这样的: 不会造成gif停止:::tip\n第一种情况是，进入代办事项弯道的时候，js会一直执行造成，无法进入渲染弯道，然后gif就停止了\n第二种情况是，进入代办事项弯道的时候，执行一次do事件，在转到主弯道的时候，渲染任务对事件循环说，我需要进行一次渲染，这个时候，事件循环进入渲染弯道渲染，然后又进入待办事件弯道，每一次都只会执行一个代办事项，就这样循环着\n::::::tip\n也说明了一点：渲染可以在任务之间发生，但是并不是说一定会在两次任务之间就会发生一次渲染，浏览器尽可能的尝试高效的渲染，也许在两次三次任务之后渲染，比如当前选项卡切换了，即使发生样式变化也不会渲染，因为渲染没有任何意义，而且只有在样式发生改变的时候，才会触发渲染，又比如在60HZ的显示器上面，即使一秒钟触发1000次样式修改，浏览器也最多也只会渲染60次，因为渲染1000次没有任何意义，用户也看不到。\n:::假设在60HZ的显示器上面，我们用setTimeout(animFrame, 1000 / 60)来模拟：可能会发生下面的现象:::warning\nsetTimeout并不是为动画而设计的，他的表现并不准确，有可能在一帧中什么也不做，然后在下一帧中做，这对用户来说简直就是视觉冲击\n::::::warning\n也有可能某个任务运行时间过长，最终会移动渲染步骤，因为他们都在同一个线程中运行\n::::::tip\n而你使用requestAnimationFrame就会是这样的，他是为动画而设计的，会在计算样式和渲染之前，而不是像任务一样无法掌控运行的时机，任务和帧没有强制的关联关系，所以任何可能会发生在任何时候，从下面的图可以看到在每一帧中，时间分配的很合理，即使requestAnimationFrame里面的任务过长也不会影响当前帧的时间\n::::::tip\n当然你无法避免任务，比如一些点击之类的任务传递给你，希望你尽快做出响应，还比如一些定时器的任务，网络请求的任务等等，你已经有动画在运行了，用requestAnimation就会下面这样的\n::::::tip\n浏览器希望为开发人员提供一种监控DOM变化的方法，但是如果发生下面的情况，你是希望想听到一次，还是100次呢\n::::::tip\n答案肯定就是一次了，这里浏览器就创建了一个新的队列:微任务(microTask),他承诺你在当前js执行完毕，也就是栈空的时候就会执行所有的微任务，微任务可能发生在事件循环的任何地方，比如在requestAnimationFrame回调里面启动一个微任务，这个微任务就会在requestAnimationFrame回调栈空之后，渲染之前执行，也说明了如果有一个一直执行的微任务队列，那么浏览器也就会卡死\n:::看个例子:我们给一个DOM绑定两个事件:::tip\n当我们点击DOM的时候，会打印2,1,4,3\n:::但是如果是js触发的呢:::tip\njs触发的时候，就会打印2,4,1,3\n::::::warning\njs调用触发的时候，两次回调没有执行完，dom.click()这里的javascript不会从栈里面移除，导致微任务一直不能触发，最后才会触发\n::::::tip\nrequestIdleCallback注册的回调函数，可以在当前帧渲染的时候，如果这一帧渲染还有剩余的时间，就会在这一帧的末尾执行，因此可以用这个函数捕捉一帧的最后时机\n:::",
        "moduleIntro": "干货",
        "path": "/Foods/eventLoop"
      },
      {
        "module": "Foods",
        "title": "理解Http请求的状态码",
        "introduction": "以 1 开头：表示连接仍在进行，并发送一些信息。以 2 开头：表示成功连接。200 说明「一切正常」。201-206 则表示还有更多内容，如创建了新资源或无任何内容需要返回。以 3 开头：表示重定向，如 301 是永久重定向，302 和 307 是临时重定向。以 4 开头：表示客户端存在错误，如 404 表示请求的资源不存在，403 则表示不允许用户访问。以 5 开头：表示服务器端存在错误，如数据库连接失败或服务器关闭。:::tip\n1.写情书 2.追求成功 3.情书递错人了 4.被拒绝 5.单相思\n:::",
        "moduleIntro": "干货",
        "path": "/Foods/httpStatusCode"
      },
      {
        "module": "Foods",
        "title": "利用Etag追踪用户",
        "introduction": "有另一种方法可以跟踪用户而不使用cookies或Javascript。这种方法 已经被用于无数网站，但几乎没人人们知道。本页解释这种方法是如何运作的，以及是如何保护你自己的。有另一种方法可以跟踪用户而不使用cookies或Javascript。这种方法 已经被用于无数网站，但几乎没人人们知道。本页解释这种方法是如何运作的，以及是如何保护你自己的。这种跟踪方式 无需使用:相反，它使用另一种存储方式，在浏览器重启的时候也可以保持持久性，这就是： caching.即使你完全禁用cookies、关闭Javascript功能并且使用VPN，这种技术依然可以追踪到你。在线示例：http://lucb1e.com/rp/cookielesscookies/我们继续，输入一些东西然后保存。接着关闭你的浏览器再一次打开这个页面。它是不是还在那儿呢？检查你的cookies，有没有？当然没有，因为它完完全全在一张假图片的校验和里，几乎没人能意识到。看到页面顶部右边的眼睛了吗？这就是我们的跟踪器。图片中的ETag是一种校验和。当图片改变时，校验和也会改变。所以当浏览器有图片并且知道校验和时，它可以将校验和传送给web服务器来验证。然后web服务器验证图片是否改变。如果没有，就不用重新传送图片了，省下了不少数据流量。细心的读者或许已经注意到，可以这样追踪人群：浏览器发送回给服务器的信息就是它之前所接收到的（ETag）。这听起来和cookies十分相似。服务器可以给每个浏览器一个唯一的ETag，浏览器再次连接时ETag可以从数据库中找出来。源代码",
        "moduleIntro": "干货",
        "path": "/Foods/EtagStorage"
      }
    ]
  },
  {
    "module": "performance",
    "title": "性能优化",
    "views": [
      {
        "module": "performance",
        "title": "重绘和回流",
        "introduction": "现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：接下来看怎么减少重绘和回流，来优化项目由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子：例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：该过程的第一步和第三步会引起回流，但是经过第一步之后，对元素进行的任何操作都不会引起重绘和回流，因为它已经不在渲染树中了有三种方式可以让DOM脱离文档流我们要执行一段批量插入节点的代码：现在使用这三种方式来进行优化这样会在隐藏和重新显示元素的时候，产生两次回流这样只会产生一次回流这样也只会产生一次回流上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:",
        "moduleIntro": "性能优化",
        "path": "/performance/repaint"
      },
      {
        "module": "performance",
        "title": "深入preload",
        "introduction": "虽然现在浏览器都做了优化，在ParseHtml开始阶段，就会开启一个下载线程，去下载所有的资源。但是在ParseHtml的时候，如果遇到外链script而且这个资源还没有下载完成还是会堵塞DOM构建的，会等待资源下载完毕，并且执行完毕，才会继续构建DOM，还有一些首屏资源隐藏在js中，或者css中，浏览器是无法知道的，只能延迟到下一次下载preload 一个基本的用法是提前加载资源，尽管大多数基于标记语言的资源能被浏览器的预加载器（Preloader）尽早发现，但不是所有的资源都是基于标记语言的，比如一些隐藏在 CSS 和 Javascript 中的资源。当浏览器发现自己需要这些资源时已经为时已晚，所以大多数情况，这些资源的加载都会对页面渲染造成延迟。HTML 解析器在创建 DOM 时如果碰上同步脚本（synchronous script)，解析器会停止创建 DOM，转而去执行脚本。所以，如果资源的获取只发生在解析器创建 DOM时，同步脚本的介入将使网络处于空置状态，尤其是对外部脚本资源来说，当然，页面内的脚本有时也会导致延迟。预加载器（Preloader）的出现就是为了优化这个过程，预加载器通过分析浏览器对 HTML 文档的早期解析结果（这一阶段叫做“令牌化（tokenization）”），找到可能包含资源的标签（tag），并将这些资源的 URL 收集起来。令牌化阶段的输出将会送到真正的 HTML 解析器手中，而收集起来的资源 URLs 会和资源类型一起被送到读取器（fetcher）手中，读取器会根据这些资源对页面加载速度的影响进行有次序地加载。看下面这段代码的执行过程：可以看到html下载完毕，在执行Parse HTML阶段并发的发出了基于标记语言的三个资源请求(index.css、index1.js、index.js)我们再看下使用preload之后的资源加载情况：使用了preload可以看到index1.js在HTML下载完毕，立马就发出了资源请求，而另外两个还是在Parse HTML阶段发出的资源请求，虽然时间相差不大(118.8ms，119.3ms)但是对于一些小的资源请求来说，可能已经足够下载了并不是所有的资源请求都适合放到preload，这样会造成不必要的资源请求，以及导致并发上限，影响首屏资源请求as 属性的作用是告诉浏览器被加载的是什么资源，可能的 as 值包括：忽略 as 属性，或者错误的 as 属性会使 preload 等同于 XHR 请求，浏览器不知道加载的是什么，因此会赋予此类资源非常低的加载优先级。对字体的提前加载web 字体是较晚才能被发现的关键资源（late-discovered critical resources）中常见的一类 。web 字体对页面文字的渲染资至关重要，但却被深埋 CSS 中，即便是预加载器有解析 CSS，也无法确定包含字体信息的选择器是否会真正应用在 DOM 节点上。理论上，这个问题可以被解决，但实际情况是没有一个浏览器解决了这个问题。而且，即便是问题得到了解决，浏览器能对字体文件做出合理的预加载，一旦有新的 css 规则覆盖了现有字体规则，前面的预加载就多余了。总之，非常复杂。但有了 preload 这个标准，简单的一段代码就能搞定字体的预加载。需要注意的一点是：crossorigin 属性是必须的，即便是字体资源在自家服务器上，因为用户代理必须采用匿名模式来获取字体资源。type 属性可以确保浏览器只获取自己支持的资源。尽管Chrome 支持 WOFF2，也是目前唯一支持 preload 的浏览器，但未来或许会有更多的浏览器支持 preload，而这些浏览器支不支持 WOFF2 就不好说了。",
        "moduleIntro": "性能优化",
        "path": "/performance/preload"
      },
      {
        "module": "performance",
        "title": "高性能函数",
        "introduction": ":::tip\n主要说一下分时函数:我们创建一个函数，然节点的添加分时进行，比如把在1s添加1000个节点改为每隔200ms添加20个节点。\n:::",
        "moduleIntro": "性能优化",
        "path": "/performance/performanceFunctions"
      }
    ]
  },
  {
    "module": "webpack",
    "title": "webpack总结",
    "views": [
      {
        "module": "webpack",
        "title": "性能优化",
        "introduction": "webpack内置的压缩，或者是插件压缩，都无法压缩css内容，因为当你导入css的时候，css-loader是把css内容解析成了字符串，而压缩器是基于AST的，没有办法分析字符串的，所有需要在loader编译阶段就压缩👇所以需要css-loader来负责压缩:::warning\n最新的css-loader已经不再支持minimize配置，可以采用cssnano来压缩css\n:::一些大型的库，针对这个环境变量做了一些操作，比如说Vue，开发环境多了很多警告React根据环境变量加载指定的文件，以及一些警告在webpack3中需要DefinePlugin来定义在webpack4中可以通过optimization.nodeEnv来定义，如果不定义默认就是mode的值image-webpack-loader支持所有格式的图片压缩，特别方便htmlWebpackPlugin结合html-webpack-inline-source-plugin插件，内联js以及css例如：内联runtime利用@vue/preload-webpack-plugin提高首屏需要的资源，达到预加载的作用",
        "moduleIntro": "webpack总结",
        "path": "/webpack/performance"
      },
      {
        "module": "webpack",
        "title": "eslint新的规则",
        "introduction": "比如一些大的资源包，或者是引入的资源包，有可以替代的方案，可以使用eslint来禁用:::tip\nmoment.js可以使用date-fns来替代\n::::::tip\nlodash可以使用lodash-es来替代\n:::no-restricted-import",
        "moduleIntro": "webpack总结",
        "path": "/webpack/eslintNewRules"
      }
    ]
  },
  {
    "module": "github",
    "title": "github总结",
    "views": [
      {
        "module": "github",
        "title": "github小技巧",
        "introduction": "Git.io是Github的短网址服务在代码文件地址后加上#L52或者单击行号52都会将第52行代码高亮显示。多行高亮也可以，比如用#L53-L60选择范围，或者按住 shift键，然后再点击选择的两行。可以在Pull Requests, Issues, 提交消息, Markdown文件里加入表情符。使用方法:name_of_emoji:Github支持的完整表情符号列表详见emoji-cheat-sheet.com 或 scotch-io/All-Github-Emoji-Icons。别名用来帮助你定义自己的git命令。比如你可以定义 git a 来运行 git add --all。要添加一个别名， 一种方法是打开 ~/.gitconfig 文件并添加如下内容：...或者在命令行里键入：例如：比如：所有的Github btn\n完整的请查看官网shields.io所有上传到npm上面的包，都默认会有一个cnd的访问路径，这个服务是由unpkg提供的。例如: https://unpkg.com/vue具体使用请查看unpkg官网又有人根据unpkg，提供了一种可以查看npm包详细文件以及信息的服务(runpkg)，只需要将原来的unpkg.com改成runpkg.com就可以了。例如: https://runpkg.com/vue更多用法请查看runpkg github",
        "moduleIntro": "github总结",
        "path": "/github/skills"
      },
      {
        "module": "github",
        "title": "git常用命令",
        "introduction": ":::tip\n查看所有已经合并到当前分支的分支列表\n::::::tip\n查看所有没有合并到当前分支的分支列表\n::::::tip\n查找哪一次代码提交引入了错误\n:::它的原理很简单，就是将代码提交的历史，按照两分法不断缩小定位。所谓\"两分法\"，就是将代码历史一分为二，确定问题出在前半部分，还是后半部分，不断执行这个过程，直到范围缩小到某一次代码提交网页上是一个计数器，有两个按钮。点击+号按钮，可以看到计数器没有递增，反而递减，这说明代码有问题。可以看到，这个库一共有101次提交。最早的第一次提交的哈希是4d83cf。git bisect start命令启动查错，它的格式如下:面代码中，\"终点\"是最近的提交，\"起点\"是更久以前的提交。它们之间的这段历史，就是差错的范围。这个例子中，我们选择全部的代码历史。起点是第一次提交4d83cf，终点是最近一次的HEAD。当然，指定其他范围也可以。执行上面的命令以后，代码库就会切换到这段范围正当中的那一次提交，本例是第51次提交。现在刷新浏览器，点击+按钮，发现可以正常递增。使用git bisect good命令，标识本次提交（第51次）没有问题。既然第51次提交没有问题，就意味着错误是在代码历史的后半段引入的。执行上面的命令，Git 就自动切换到后半段的中点（第76次提交）。现在刷新浏览器，点击+按钮，发现不能正常递增。使用git bisect bad命令，标识本次提交（第76）有问题。执行上面的命令以后，Git 就自动切换到第51次到第76次的中点（第63次提交）。接下来，不断重复这个过程，直到成功找到出问题的那一次提交为止。这时，Git 会给出如下的提示。然后，使用git bisect reset命令，退出查错，回到最近一次的代码提交。",
        "moduleIntro": "github总结",
        "path": "/github/gitOften"
      },
      {
        "module": "github",
        "title": "把github当成静态服务使用",
        "introduction": "githubusercontent.com是github的素材服务器，也就是静态服务器，可以直接访问。实际上，文件到了github就到了raw.githubusercontent.com。到文件的页面，点击download就可以跳转到新的一页，复制其URL就可以啦。复制URL在issues里面图片可以直接拖拽，提交issues之后的静态资源可以直接访问。",
        "moduleIntro": "github总结",
        "path": "/github/githubStaticServer"
      }
    ]
  },
  {
    "module": "html",
    "title": "html相关",
    "views": [
      {
        "module": "html",
        "title": "新的标签",
        "introduction": "效果：Ruby原指5.5级的字体格式，在美国又称Agate，它的大小正好适合注音。现在在日文中，这词不再表示字体的名称，而是表示名词形式的标音。当它被翻译回英文时，它被称为rubi（由假名译来，日文：ルビ）。但是Ruby的拼法还是比较普遍。我认为应该是英国人认为5.5级的字体格式像红宝石一样美观，故名。:::tip\n<base> 标签为页面上的所有链接规定默认地址或默认目标。\n通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。使用 <base> 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 <a>、<img>、<link>、<form> 标签中的 URL\n::::::tip\n<article>元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目\n::::::tip\n描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表.\n::::::tip\n表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者标注框\n::::::tip\n表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）\n::::::tip\n用于展示介绍性内容，通常包含一组介绍性的或是辅助导航的实用元素。它可能包含一些标题元素，但也可能包含其他元素，比如 Logo、搜索框、作者名称，等等\n::::::tip\n表示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息\n::::::tip\n呈现了文档的 <body> 或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成\n::::::tip\n表示其中的 HTML 提供了某个人或某个组织（等等）的联系信息\n::::::tip\n示预定义格式文本。在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <pre> 开始标签后的换行符也会被省略)\n::::::tip\n代表其中的文字是引用内容\n:::",
        "moduleIntro": "html相关",
        "path": "/html/newLabel"
      }
    ]
  },
  {
    "module": "vscode",
    "title": "vscode技巧",
    "views": [
      {
        "module": "vscode",
        "title": "个性化定制颜色",
        "introduction": "VS Code使用TextMate语法将文本分解为标记列表:::tip\n查询textMate步骤：设置inspectTMScopes快捷键查看\n```json\n{\n\"key\": \"cmd+alt+shift+i\",\n\"command\": \"editor.action.inspectTMScopes\"\n}然后对准需要设置的语法使用快捷键会看到属于哪个textMate然后在settings.json里面设置editor.tokenColorCustomizations",
        "moduleIntro": "vscode技巧",
        "path": "/vscode/customeColor"
      },
      {
        "module": "vscode",
        "title": "实用快捷键",
        "introduction": ":::tip\n向下重开一行\n::::::tip\n向上重开一行\n::::::tip\n删除一行\n::::::tip\n把代码往上移动一行\n::::::tip\n把代码往下移动一行\n::::::tip\n往上复制一行代码\n::::::tip\n往下复制一行代码\n::::::tip\n搜索\n::::::tip\n在项目中搜索\n::::::tip\n自定义代码片段: 打开 vsocde 的 首选项 > 用户代码片段 ，选择代码片段文件为 vue.json。输入以下内容。\n:::保存后，新建一个Test.vue，输入vuec,可以快速插入代码块",
        "moduleIntro": "vscode技巧",
        "path": "/vscode/practicalShortcutKey"
      },
      {
        "module": "vscode",
        "title": "调试",
        "introduction": "package.jsonlanuch.json",
        "moduleIntro": "vscode技巧",
        "path": "/vscode/debugger"
      }
    ]
  },
  {
    "module": "npm",
    "title": "关于npm的知识",
    "views": [
      {
        "module": "npm",
        "title": "npm技巧",
        "introduction": "这个实在npmv5.2.0引入的一条命令。引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。举个例子，我们开发中要运行 parcel 命令来打包：parcel index.html，以前有这么几种方式：全局安装 parcel，但有时不同项目使用不同版本，不允许使用全局包，只能考虑下面一些方法使用 npm scripts，在 package.json 加一个 script将 node_modules 的可执行目录加到 PATH 中指定可执行命令路径现在我们有了npx命令，就不在需要考虑以上方法了（其实\n npx是对方法 3 的封装）。当我们执行npx parcel index.html时，会自动去./node_modules/.bin目录下搜索npx还允许我们单次执行命令而不需要安装，例如：这条命令会临时安装 create-react-app 包，命令完成后 create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。npm 允许在package.json文件里面，使用scripts字段定义脚本命令。上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。命令行下使用npm run命令，就可以执行这段脚本。这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。项目的相关脚本，可以集中在一个地方。不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。可以利用 npm 提供的很多辅助功能。查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。而不用写成下面这样。由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。上面代码中，*表示任意文件名，**表示任意一层子目录。如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。向 npm 脚本传入参数，要使用--标明。向上面的npm run lint命令传入参数，必须写成下面这样。也可以在package.json里面再封装一个命令。如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&符号。如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。用户执行npm run build的时候，会自动按照下面的顺序执行。因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用$npm_package_name和$npm_package_version取到这两个值。上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。下面是另外一个例子。上面代码中，npm_package_scripts_install变量的值等于foo.js。然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。注意，package.json里面的config对象，可以被环境变量覆盖。上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。最后，env命令可以列出所有环境变量。配置多个命令命令行入口一定加上：",
        "moduleIntro": "关于npm的知识",
        "path": "/npm/skill"
      },
      {
        "module": "npm",
        "title": "版本管理",
        "introduction": "SemVer根据国际主流的惯例，我们使用「语义化版本（Semantic Versioning）」的命名方式，有时简称 SemVer。语义化版本号（以下简称「版本号」）的格式是：<major>.<minor>.<patch>。即使用三位非负整数，以点号 . 连接。如：1.4.15、6.2.0。当要发布大版本或者核心的Feature时，但是又不能保证这个版本的功能 100% 正常。这个时候就需要通过发布先行版本。比较常见的先行版本包括：内测版、灰度版本了和RC版本。Semver规范中使用alpha、beta、rc(以前叫做gama)来修饰即将要发布的版本。预发版本号的格式是 <major>.<minor>.<patch>-<tag>，即前半部分和常规版本号相同，然后跟上连接符 -，后面再跟上字母数字点号连接符（[0-9A-Za-z-.]）。下面是react的版本：当执行npm install package -S 来安装三方包时，npm 会首先安装包的最新版本(latest)，然后将包名及版本号写入到 package.json 文件中项目对包的依赖可以使用下面的 3 种方法来表示(假设当前版本号是 16.2.0):例：初始版本为1.0.0:::warning\n当仓库已经被git初始化了，那么运行npm version修改完版本号以后，还会运行git add 、git commit和git tag的命令，其中commit的信息默认是自改完的版本号。如果想自定义commit的信息，可以提供 -m 或者 —message 的选项，如果有\"%s\"的符号，会被替换为版本号。\nnpm version patch -m \"Upgrade to %s for reasons\"\n:::如何发布预发版本的包:::tip\n执行npm publish的时候默认指定了tag值就是latest默认是稳定版本发布，相当于：\nnpm publish --tag latest\n:::比如发布16.9.0-alpha.0版本的内测包比如安装16.9.0-alpha.0版本的内测包：可以通过指定tag的方式:::warning\n一个tag只会存在一个包，如果发布了新的内测包alpha，那么16.9.0-alpha.0这个包就变成了latest包\n:::也可以直接通过版本号来安装比如公测包(beta)，稳定后，需要将beta包设置为latest包，让用户使用那么就是使用：比如将16.9.0-alpha.0设置成稳定包：",
        "moduleIntro": "关于npm的知识",
        "path": "/npm/versionManager"
      },
      {
        "module": "npm",
        "title": "npm调试技巧",
        "introduction": "最终生成package.json:什么是软链：比如说我创建了一个 /path/link.js 到 /path/file.js 的软链接，则当我访问 link.js 的时候，实际上相当于访问 file.js 。如果我把 file.js 删除的话，再去访问 link.js 就会报错。也可以分步骤的添加：:::tip\n创建软链之后，项目的node_modules目录下会多出文件包名的资源文件夹，就可以直接使用当前这个模块了，在vscode里面，可以查看资源包带有箭头标志，如下图：\n:::",
        "moduleIntro": "关于npm的知识",
        "path": "/npm/debugger"
      },
      {
        "module": "npm",
        "title": "package-lock.json的作用",
        "introduction": "场景如下：在一个团队内部，一个开发同学对领导说他的项目有问题，然后领导拉下项目之后，执行npm install发现没有任何问题，可能的一个原因就是两个人安装的npm包不一致，比如说项目中有使用到一个组件库，开发同学开发的时候，使用的是1.0.0，但是这个版本有bug，然后组件库更新到1.0.1将原有的bug修复了，然后领导安装的包就没有问题，这就导致问题难以复现，多个人的开发环境依赖不一致的问题。:::tip\n而package-lock.json的作用就是用来保证我们的应用程序依赖之间的关系是一致的, 兼容的。本地开发环境和线上编译环境依赖一致的作用。\n::::::warning\n这就引发一个问题，如果lock文件里面的内容不变，想要升级原有的npm包是不可能的，因为使用都会从lock里面读取依赖的具体数据\n:::package-lock.json file not updated after package.json file is changed · Issue #16866 · npm/npm:::warning\n这就引发不同的地方，项目依赖不一致的问题\n:::why is package-lock being ignored? · Issue #17979 · npm/npm如果两者是同一状态，那么执行npm i都会根据lock下载，不会理会package实际包的版本是否有新。:::tip\n这样就能解决又根据lock保证不同的地方依赖项一致的问题，又能解决可以手动修改依赖项版本的问题\n:::",
        "moduleIntro": "关于npm的知识",
        "path": "/npm/packageLock"
      },
      {
        "module": "npm",
        "title": "模块安装机制",
        "introduction": ":::warning\nnpm包通过package-lock.json是不能锁定版本，只能通过package.json指定固定版本来锁定。\n:::锁定版本的package.json逻辑结构：就是每个依赖项下面依赖资源都是以层级的形式嵌套在各自的模块node_modules下面。物理结构：就是安装的时候，实际上各个资源在项目node_modules下层级情况。可以使用命令查看项目的层级结构tree -d命令以树状图的方式列出一个项目下所有依赖的物理结构npm ls命令以树状图的方式列出一个项目下所有依赖的逻辑结构:::tip\n可以使用控制台重定向功能(>)将控制台的内容，输出到文件中。\ntree -d > tree.md\n:::npm2安装多级的依赖模块采用嵌套的安装方式：:::tip\n优点：实现多版本兼容 \n缺点：造成相同模块大量冗余的问题\n:::依赖包的依赖包相同，这就造成了大量代码冗余npm3和npm2的不同主要体现在二级模块的安装上：npm3会\"尽量\"把逻辑上某个层级的模块在物理结构上\"全部\"放在项目的第一层级里，具体我概括为以下三种情况：:::tip\n1、在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级\n::::::tip\n2、在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块。\n:::对npm2,两个C包是相同的，造成模块冗余在npm3中，因为A模块下的C模块被安装到了第一级，这使得B模块能够复用处在同一级下；且名称，版本，均相同的C模块npm3就是用这种方式，部分地解决了npm2的痛点（部分）:::tip\n3、在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方\n:::在npm3中，因为B和A所要求的依赖模块不同，（B下要求是v1.0的C，A下要求是v2.0的C ）所以B不能像2中那样复用A下的C v1.0模块:::warning\n实际上：npm3中仍然可能出现模块冗余的情况，因为一级目录下已经有v1.0的C模块了，所以所有的v2.0只能作为二级依赖模块被安装，这样你就会看到如下的情况\n:::npm dedupe尽量压平依赖树，它能够把凡是能够去除的冗余的二级依赖模块，“重定向”到名称／版本相同的一级模块。:::tip\n每次安装/卸载了包之后最好重新执行npm dedupe，以保证包结构是最优的\n:::",
        "moduleIntro": "关于npm的知识",
        "path": "/npm/installDetail"
      },
      {
        "module": "npm",
        "title": "npm实用命令",
        "introduction": "会检测当前安装的所有npm包是否有更新，并列出可以更新的包，如果没有任何输出，那么恭喜你，所有的包都是不需要更新的。:::tip\n使用场景: 在执行npm update之前，可以先使用npm outdated查看下具体要更新哪些包，是否有影响。\n::::::tip\n每次安装依赖或者卸载依赖之后使用，可以保证依赖的结构是最优的。\n:::",
        "moduleIntro": "关于npm的知识",
        "path": "/npm/command"
      }
    ]
  },
  {
    "module": "project",
    "title": "前端工程化",
    "views": [
      {
        "module": "project",
        "title": "理解babel",
        "introduction": "babel将所有可以转换的语法都写成一个一个的插件，比如转换箭头函数需要@babel/plugin-transform-arrow-functions，转换let,const需要@babel/plugin-transform-block-scoping。:::tip\n如果是这样项目就需要配置很多的plugin，所以官方就把一些常用的插件封装起来，安装这个预设就相当于安装了这些插件，可以吧Preset理解为套餐，每个套餐里面打包一系列的插件，这样安装套餐就相当于安装了大量的插件。\n:::可以查看项目下@babel/preset-env/data/plugin-features.js文件查看当前env维护的插件列表，也可以直接通过babel-env-plugins来查看。:::tip\n我们可以封装一个preset给特定的环境使用比如APP端使用，例如@vue/babel-preset-app，文档可以查看创建 Preset\n:::虽说浏览器的特性支持状况千差万别，但其实可以提炼出两类：\n1、大家都有，只是 A 语法与 B 语法的区别；\n2、不是大家都有：有的有，有的没有。:::tip\nbabel 编译过程处理第一种情况 - 统一语法的形态，通常是高版本语法编译成低版本的，比如 ES6 语法编译成 ES5 或 ES3。而 babel-polyfill 处理第二种情况 - 让目标浏览器支持所有特性，不管它是全局的，还是原型的，或是其它。这样，通过 babel-polyfill，不同浏览器在特性支持上就站到同一起跑线。\n:::为什么需要 polyfill 这所谓的垫片？前面聊到 @babel/preset-env 时，不是说只要定义好我想支持的目标浏览器，babel 就能编译出能运行在目标浏览器上的代码吗？:::tip\n拿 findIndex 来说,IE 11不支持该方法，babel只能转译语法层面的，即使编译，不支持findIndex的浏览器还是不兼容，这时候就需要垫片polyfill：如果目标环境中已经存在 findIndex，我们什么都不做，如果没有，我们就在 Array 的原型中定义一个。可以看findInex的垫片如下：\n:::我们拿 Object.assign 为例，剖析下 babel-polyfill 与 babel-runtime 的异同。我们知道，IE 11 不支持 Object.assign，此时，我们有俩种候选方案：1、引入 babel-polyfill，补丁一打，Object.assign 就被创造出来\n2、配置 @babel/plugin-transform-object-assign第二种方案中，babel 会将所有的 Object.assign 替换成 _extends 这样一个辅助函数。如下所示：编译成:::warning\n问题是，如果你的项目里有 100 个文件，其中有 50 个文件里写了 Object.assign，那么，坏消息来了，_extends 辅助函数会出现 50 次\n:::怎么办？我们自然而然会想到把 _extends 分离出去，然后在每个文件中引入 - 这正是 @babel/runtime 的作用：:::tip\npreset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是 ['es2015', 'stage-0']。这样必须先执行 stage-0 才能确保 babel 不报错。因此我们编排 preset 的时候，也要注意顺序，其实只要按照规范的时间顺序列出即可。\n::::::tip\n1、presets实际上就是一系列的插件集合\n2、babel-runtime实际上和babel-polyfill干的事情是一样的，但他不会污染全局命名空间和原型\n3、babel-runtime是一些垫片也就是实现的方法，而分离这些方法，是需要插件支持的(transform-runtime)所以，这两个必须一起使用\n4、babel-runtime既然是垫片就必须是项目依赖('dependencies')\n5、虽然babel-runtime和babel-polyfill干的事情差不多，但是比如myArray.includes(1)这些实例方法，babel-runtime是无能为力的。只能使用babel-polyfill\n6、babel-polyfill 与 babel-runtime 的一大区别，前者改造目标浏览器，让你的浏览器拥有本来不支持的特性；后者改造你的代码，让你的代码能在所有目标浏览器上运行，但不改造浏览器\n:::",
        "moduleIntro": "前端工程化",
        "path": "/project/understandsBabel"
      },
      {
        "module": "project",
        "title": "babel配置技巧",
        "introduction": ":::tip\n在package.json里面配置了browserslist，就不需要在.babelrc里面配置targets::::::warning\n配置的浏览器不区分大小写: 如Android >= 8.0 和android >= 8.0都是可以的\n具体的浏览器配置文档可以查看\n:::",
        "moduleIntro": "前端工程化",
        "path": "/project/babelConfig"
      }
    ]
  },
  {
    "module": "flutter",
    "title": "flutter学习",
    "views": [
      {
        "module": "flutter",
        "title": "配置开发环境",
        "introduction": "1、安装flutter sdk2、 解压flutter sdk到指定目录3、添加flutter sdk到环境变量:::warning\n这样添加环境变量，仅能在当前终端而且当前窗口使用，也就是关闭终端重新使用，就找不到flutter了，可以采用以下方式，将sdk添加到全局环境变量。\n:::创建$HOME/.bash_profile文件，如果有的话，直接使用。这个文件，是用户级的环境变量文件将flutter sdk的bin添加到环境变量中（将下面的内容写到$HOME/.bash_profile文件中）运行source $HOME/.bash_profile刷新当前终端运行echo $PATH看flutter/bin是否在其中，来判断是否添加成功:::warning\nMac系统的环境变量，加载顺序为：/etc/profile，/etc/paths，~/.bash_profile，~/.bash_login，~/.profile，~/.bashrc。当然/etc/profile和/etc/paths是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。后面3个按照从前往后的顺序读取，如果/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，如果/.bash_profile文件不存在，才会以此类推读取后面的文件。~/.bashrc没有上述规则，它是bash shell打开的时候载入的。\n::::::tip\n添加到$HOME/.bash_profile之后，你会发现关闭终端之后，还是找不到flutter，这是因为：若bash shell是以login方式执行时，才会读取此文件。该文件仅仅执行一次!，如果不想重启，可以将source ~/.bash_profile添加到~/.zshrc。\n打开vim ~/.zshrc  添加source ~/.bash_profile ，这样~/.bash_profile配置的环境变量同样有效\n关于Mac环境变量可以参考mac中添加环境变量无效\n:::",
        "moduleIntro": "flutter学习",
        "path": "/flutter/setEnvironment"
      },
      {
        "module": "flutter",
        "title": "flutter命令",
        "introduction": "<app-name>可以是.，在当前目录创建，并以当前文件夹名称作为项目名称。启动项目是需要安装模拟器的，在Mac上面Xcode自带了模拟器，在跑项目之前，需要先启动模拟器:::tip\n在Mac上面可以使用open -a Simulator命令来查找启动模拟器。\n:::",
        "moduleIntro": "flutter学习",
        "path": "/flutter/command"
      },
      {
        "module": "flutter",
        "title": "基本语法",
        "introduction": " 1、 var也可以申明变量，一种声明变量而不指定其类型的方法。:::tip\n因为 ，var 并不是直接存储值，而是存储的值的对象的引用，例如：var content = 'Dart 语法' 这句，是名字为 content 的 var 变量存储了值为 'Dart 语法' 的 String 对象的引用，所以 var 才能定义任何变量。\n:::当给var变量赋值了之后，就确定了这个变量的数据类型，再重新赋值的时候，只能是初始赋值的数据类型。2、$variableName 或 ${expression}字符串插值：将变量的值直接插入字符串中。3、dynamic（[daɪ'næmɪk]）意思是数据类型是动态可变的，也可以定义任何变量，但是和var不同的是，var一旦赋值后，就不能改变数据类型了，但是dynamic可以。:::warning\n请不要滥用dynamic，一般情况下都可以用Object代替dynamic。\n什么情况下使用：当这个变量没法用 Dart 的类型来表示时，比如 Native 和 Flutter 交互，从 Native 传来的数据。所以你会看到 PlatformChannel 里有很多地方使用到了dynamic。\n:::4、ObjectDart 里所有东西都是对象，是因为 Dart 的所有东西都继承自Object，因此Object可以定义任何变量，而且赋值后，类型也可以更改。5、 常量: final和const如果你不想更改变量的值，那么你可以用 final 和 const:常量有以下特点：:::tip\n以下划线_开头的类或成员变量是私有的。\nDart 没有 Public、Protected、Private 的关键字，在 Dart 里，类或成员变量默认都是 Public 的，以下划线 _ 开头的就是私有的，例如成员变量 _name 就是私有的。\n:::函数的格式如下：例如：1、函数的类型是Function判断函数say的类型是不是Function，用is来判断。2、必选参数和可选参数判断是必选参数还是可选参数：首先必选参数在前面，和普通的参数定义一样，后面跟可选参数，可选参数需要用{}或者[]包起来，用不同的括号，可选参数的意义与用法也不一样。可选参数也分为两类：1、可选命名参数：使用 {} 包起来的参数是可选命名参数。2、可选位置参数：使用 [] 包起来的参数是可选位置参数。用 {} 包起来的参数是可选命名参数，前面讲数据类型的时候，使用 {} 来赋值的数据类型是 Map，所以可选的命名参数的类型也是 Map， 因此调用函数时，可选参数的赋值必须是 paramName: value 这种 key: value 格式的，下面是可选命名参数的例子：要调用 say 函数，方法如下：同时还可以给命名参数加 @required ，意思是这个也是必填参数，例子如下：这时候要调用 say 函数，方法如下：用 [] 包起来的参数是可选位置参数，前面讲数据类型的时候，使用 [] 来赋值的数据类型是 List，所以可选的命名参数的类型也是 List，所以赋值和参数是一一对应的，下面是可选位置参数的例子要给可选位置参数赋值时，必选按照顺序来赋值：因为参数是可选的，那么参数的值很可能没有赋值，就是 null ，用到的时候就有可能会触发 NPE，所以可以给可选参数赋默认值。使用 = 为可选参数赋默认值=> 语法是 { return expr; } 的简写，因为 => 酷似箭头，也称箭头语法,也是 Lambda 表达式。:::warning\n=> 语句后面只能跟一行代码，而且这一行代码只能一个表达式，而不能跟语句。表达式可以是函数、值。\n:::例如，main() 函数这里:等价于:Dart 中每个对象都是一个类的实例，所有类都继承自 Object。1、自定义类如下，我定义一个类 Point：2、默认构造函数的写法默认的构造函数就是使用类名作为函数名的构造函数，例如上面写的类 Point 的构造函数：Point(num x,num y)。3、构造函数的语法糖Dart 里还有构造函数的语法糖，可以将构造函数改造为：这个语法糖会简化构造函数的赋值操作。4、Widget 构造函数参数采用的是可选命名参数。因为 Widget 构造函数有很多参数，为了使用起来清晰，Widget 构造函数的参数采用的是可选命名参数。5、创建实例的时候不再需要new。创建类实例的时候，都要写 new，其实很麻烦的，而且也没有必要，所以 Dart 在创建实例的时候不在需要使用 new 。6、使用类的变量使用点 . 来引用实例变量或方法：Dart 中定义了很多的操作符，分为以下几类：1、算术运算操作符2、相等和大小关系操作符3、类型判断操作符:::warning\n上面的例子中，如果 emp 是 null 的话，as 的例子就会抛异常，is 和 isn't 的例子会返回 false。\n:::4、赋值操作符赋值操作符是 =。如果只想当被赋值的变量为空的时候才赋值，可以使用??=,例如：= 还可以和其他操作符结合起来使用，例如:这些组合起来的操作符，意思是先进行操作，然后在赋值，例如：5、逻辑运算操作符6、按位与移位运算符7、条件运算符Dart 有两个运算符，可以让您使用更简单的表达式来代替可能需要 if-else 语句的表达式：如果 condition 是 true，返回 expr1，否则返回 expr2。如果 expr1 为 null，就返回 expr2 的值，否则返回 expr1 的值。8、级联操作符级联操作符是 ..,允许你对同一对象进行一系列的操作。除了函数调用，您还可以访问同一对象上的字段。这通常可以为您节省创建临时变量的步骤，并允许您编写更多流畅的代码。querySelector() 返回一个 selector 对象，后面的 ..text、..classes、..onClick就是在 selector 对象上进行的。9、其他操作符在说一下 Dart 里很好用但容易搞混的几个操作符：?.、 ?? 、??=想要访问表达式的某个属性时，就可以使用这个，可以有效避免 NPE。等效于：在赋值时，可以使用 ??，若发现为空，可以为其赋默认值。 例如:等价于：expr1 ??= expr2 等效于 expr1 = expr1 ?? expr2 就是判断 expr1 是否为null，如果为null的话，就使用默认值 expr2。 例如：等价于：",
        "moduleIntro": "flutter学习",
        "path": "/flutter/baseSyntax"
      },
      {
        "module": "flutter",
        "title": "widget的使用",
        "introduction": "Flutter 中的 Widget 相当于 Android 里的 View，iOS 里的 UIView。在 Flutter 中要用 Widget 构件 UI。Flutter 的 Widget 渲染采用的是类似 React 的框架：当 Widget 状态发生变化，需要更新界面时，框架会先计算从上一个状态转换到下一个状态所需的最小更改，然后再去刷新界面。这是 Flutter Framework 层的架构图，可以看到 Framework 里面有一层是 Widgets。在 Widgets 层下面，有：Widgets 下面的层提供的是最基本的功能，但是这些平时很少使用到，因为要使用这些的话会比较复杂。我们在开发中使用的都是封装好的东西，也就是 Widgets 上面的那层：1、Material（[mə'tɪrɪəl]: 材料，原料） & Cupertino（库比蒂诺（苹果电脑的全球总公司所在地，位于美国旧金山））Material & Cupertino 指的 Widget 的风格是 Material 或 Cupertino 。Flutter 为了减轻开发人员的工作量，实现了两种不同风格的组件：Material 和 Cupertino 。Material 用于 Android，Cupertino 用于 iOS。有了这些组件，开发人员不需要再做额外的工作，就可以让 Flutter 的 UI 风格适应不同的平台，让 Flutter UI 获得和 Native UI 一样的使用体验。2、根 WidgetFlutter会默认把 根Widget 充满屏幕。在 Flutter 中，根Widget 只能是以下三个：1、WidgetsApp：WidgetsApp 是可以自定义风格的 根Widget。2、MaterialApp：MaterialApp 是在 WidgetsApp 上添加了很多 material-design 的功能，是 Material Design 风格的 根Widget。3、CupertinoApp：CupertinoApp 也是基于 WidgetsApp 实现的 iOS 风格的 根Widget。3、Widget 的分类：StatelessWidget 和 StatefulWidget因为渲染是很耗性能的，为了提高 Flutter 的帧率，就要尽量减少不必要的 UI 渲染，所以 Flutter 根据 UI 是否有变化，将 Widget 分为：StatefulWidget 是 UI 可以变化的 Widget，创建完后 UI 还可以在更改。StatelessWidget 是 UI 不可以变化的 Widget，创建完后 UI 就不可以在更改。例如：需要有两部分组成：1、StatefulWidget实现步骤:::tip\n主要功能就是创建State\n:::2、State的实现步骤:::tip\nState的两个功能:\n1、build() —— 创建 Widget\n2、setState() —— 刷新 UI\n::::::tip\n为什么 StatefulWidget 被分成 StatefulWidget 和 State 两部分？\n一方面是为了保存当前 APP 的状态，另一个重要的原因就是为了性能！当 UI 需要更新时候，假设 Widget 和 State 都重建，可是 State 里保存了 UI 显示的数据，State 重建，创建新的实例，UI 之前的状态就会丢失，导致 UI 显示异常，所以要分成两部分，一部分会重建，一部分不会重建，重建的部分就是 StatefulWidget，不会重建的部分就是 State。Widget 重建的成本很低，但 State 的重建成本很高，因此将 StatefulWidget 分成两部分：重建成本低的 Widget 和重建成本高的 State。这样就使得 State 不会被频繁重建，也就提高了性能。\n:::因为 StatefulWidget 由 StatefulWidget 和 State 两部分组成，所以也有 StatefulWidget 的生命周期和 State 生命周期。",
        "moduleIntro": "flutter学习",
        "path": "/flutter/widget"
      }
    ]
  },
  {
    "module": "standard",
    "title": "代码规范",
    "views": [
      {
        "module": "standard",
        "title": "注释规范",
        "introduction": "无论是ts还是js申明变量都可以采用jsdoc注释的形式，给别的同事使用的时候带来提示。",
        "moduleIntro": "代码规范",
        "path": "/standard/comment"
      }
    ]
  },
  {
    "module": "typescript",
    "title": "typescript使用",
    "views": [
      {
        "module": "typescript",
        "title": "ts使用技巧",
        "introduction": "有时候我们需要复用一个类型，但是又不需要此类型内的全部属性，因此需要剔除某些属性，这个时候Omit就派上用场了。:::tip\n这个方法在React中经常用到，当父组件通过props向下传递数据的时候，通常需要复用父组件的props类型，但是又需要剔除一些无用的类型。\n:::使用readonly使用类型断言(类型断言用来告诉编译器你比它更了解这个类型，并且它不应该再发出错误):::warning\n注意:这里的值不能修改,指的是数组里面的值,而不是整个数组变量,也就是说这样是可以改变的:::类型别名第一个作用是当作类型中的一个“变量”（类似于 js的const声明的变量）使用使用类型别名可以实现很多复杂的类型，很多复杂的类型别名都需要借助关键字，我们先来了解一下几个常用的关键字：extends可以用来继承一个类，也可以用来继承一个 interface，但还可以用来判断有条件类型在JS中typeof可以判断一个变量的基础数据类型，在 TS中，它还有一个作用，就是获取一个变量的声明类型，如果不存在，则获取该类型的推论类型。keyof可以用来取得一个对象接口的所有key值：in用来遍历枚举类型为了更方便的使用,typescript内部实现了一些别名,可以直接使用Partial的作用就是可以将某个类型里的属性全部变为可选项?:::success\n源码如下::::Required的作用刚好跟Partial相反，Partial 是将所有属性改成可选项，Required 则是将所有类型改成必选项-?:::success\n源码如下::::这个类型的作用是将传入的属性变为只读选项:::success\n源码如下::::这个类型则可以将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。:::success\n源码如下::::该类型可以将K中所有的属性的值转化为T类型:::success\n源码如下:::::::success\n为什么keyof any等于string, number, symbolkeyof any表示可用作对象索引的任何值的类型。目前，您可以使用string或number或symbol索引到对象:::将某个类型中属于另一个的类型移除掉:::success\n源码如下:never类型never类型表示的是那些永不存在的值的类型。never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。\n:::就是从T中提取出U:::success\n源码如下::::该类型的作用是获取函数的返回类型。:::success\n源码如下::::下面是一些可能会经常用到，但是TS 没有内置的一些类型别名：有时候我们想要继承某个接口，但是又需要在新接口中将某个属性给overwrite掉，这时候通过Pick和 Exclude 就可以组合出来 Omit，用来忽略对象某些属性功能：:::success\n源码如下::::将T的所有属性的readonly移除:::success\n源码如下::::内置的Partial 有个局限性，就是只支持处理第一层的属性，如果是嵌套多层的就没有效果了，不过可以如下自定义：:::success\n源码如下::::相同的属性名称，但使值是一个 Promise，而不是一个具体的值：:::success\n源码如下::::",
        "moduleIntro": "typescript使用",
        "path": "/typescript/skill"
      },
      {
        "module": "typescript",
        "title": "如何编写tsd文件",
        "introduction": "虽然JavaScript不支持合并，但你可以为导入的对象打补丁以更新它们。全局拓展通过global来申明:::success\n最新的typescript(3.6+)好像不再支持global\n:::直接申明全局拓展可以拓展内部自定义模块以及外部模块比如Vue比如增加Vue的根实例上面增加一个$get的请求方法通过模块导入import或者require的方式使用的模块,可以有两种方式来申明文件。1、在相应的模块文件夹下建立同名的.d.ts文件来申明:::warning\n无论在任何位置的.ts以及.d.ts文件内没有使用export申明declare的类型都将是全局的\n:::2、通过module来申明",
        "moduleIntro": "typescript使用",
        "path": "/typescript/tsd"
      },
      {
        "module": "typescript",
        "title": "运算符",
        "introduction": "也叫联合类型也叫交集类型:::warning\n联合类型和交集类型是有区别的 \n联合类型是只要满足其中一个类型就可以了:交集类型是两个类型都必须要满足:::",
        "moduleIntro": "typescript使用",
        "path": "/typescript/operator"
      }
    ]
  }
]
